// @generated by protoc-gen-nice-grpc v1 with parameter "target=ts,import_extension=js"
// @generated from file ydb_topic_v1.proto (package Ydb.Topic.V1, syntax proto3)
/* eslint-disable */

import type { MessageInitShape } from "@bufbuild/protobuf";
import { create, fromBinary, toBinary } from "@bufbuild/protobuf";
import { AlterTopicRequestSchema, AlterTopicResponseSchema, CommitOffsetRequestSchema, CommitOffsetResponseSchema, CreateTopicRequestSchema, CreateTopicResponseSchema, DescribeConsumerRequestSchema, DescribeConsumerResponseSchema, DescribeTopicRequestSchema, DescribeTopicResponseSchema, DropTopicRequestSchema, DropTopicResponseSchema, StreamReadMessage_FromClientSchema, StreamReadMessage_FromServerSchema, StreamWriteMessage_FromClientSchema, StreamWriteMessage_FromServerSchema, UpdateOffsetsInTransactionRequestSchema, UpdateOffsetsInTransactionResponseSchema } from "./protos/ydb_topic_pb.js";
import type { ServiceDefinition } from "nice-grpc";

/**
 * @generated from service Ydb.Topic.V1.TopicService
 */
export const TopicServiceDefinition = {
  /**
   * Create Write Session
   * Pipeline example:
   * client                  server
   *         InitRequest(Topic, MessageGroupID, ...)
   *        ---------------->
   *         InitResponse(Partition, MaxSeqNo, ...)
   *        <----------------
   *         WriteRequest(data1, seqNo1)
   *        ---------------->
   *         WriteRequest(data2, seqNo2)
   *        ---------------->
   *         WriteResponse(seqNo1, offset1, ...)
   *        <----------------
   *         WriteRequest(data3, seqNo3)
   *        ---------------->
   *         WriteResponse(seqNo2, offset2, ...)
   *        <----------------
   *         [something went wrong] (status != SUCCESS, issues not empty)
   *        <----------------
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.StreamWrite
   */
  streamWrite: {
    path: "/Ydb.Topic.V1.TopicService/StreamWrite",
    requestStream: true,
    requestSerialize: (message: MessageInitShape<typeof StreamWriteMessage_FromClientSchema>) => toBinary(StreamWriteMessage_FromClientSchema, create(StreamWriteMessage_FromClientSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(StreamWriteMessage_FromClientSchema,bytes),
      responseStream: true, 
    responseSerialize: (message: MessageInitShape<typeof StreamWriteMessage_FromServerSchema>) => toBinary(StreamWriteMessage_FromServerSchema, create(StreamWriteMessage_FromServerSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(StreamWriteMessage_FromServerSchema,bytes),
    options: {},
  },
  /**
   * Create Read Session
   * Pipeline:
   * client                  server
   *         InitRequest(Topics, ClientId, ...)
   *        ---------------->
   *         InitResponse(SessionId)
   *        <----------------
   *         ReadRequest
   *        ---------------->
   *         ReadRequest
   *        ---------------->
   *         StartPartitionSessionRequest(Topic1, Partition1, PartitionSessionID1, ...)
   *        <----------------
   *         StartPartitionSessionRequest(Topic2, Partition2, PartitionSessionID2, ...)
   *        <----------------
   *         StartPartitionSessionResponse(PartitionSessionID1, ...)
   *             client must respond with this message to actually start recieving data messages from this partition
   *        ---------------->
   *         StopPartitionSessionRequest(PartitionSessionID1, ...)
   *        <----------------
   *         StopPartitionSessionResponse(PartitionSessionID1, ...)
   *             only after this response server will give this parittion to other session.
   *        ---------------->
   *         StartPartitionSessionResponse(PartitionSession2, ...)
   *        ---------------->
   *         ReadResponse(data, ...)
   *        <----------------
   *         CommitRequest(PartitionCommit1, ...)
   *        ---------------->
   *         CommitResponse(PartitionCommitAck1, ...)
   *        <----------------
   *         [something went wrong] (status != SUCCESS, issues not empty)
   *        <----------------
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.StreamRead
   */
  streamRead: {
    path: "/Ydb.Topic.V1.TopicService/StreamRead",
    requestStream: true,
    requestSerialize: (message: MessageInitShape<typeof StreamReadMessage_FromClientSchema>) => toBinary(StreamReadMessage_FromClientSchema, create(StreamReadMessage_FromClientSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(StreamReadMessage_FromClientSchema,bytes),
      responseStream: true, 
    responseSerialize: (message: MessageInitShape<typeof StreamReadMessage_FromServerSchema>) => toBinary(StreamReadMessage_FromServerSchema, create(StreamReadMessage_FromServerSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(StreamReadMessage_FromServerSchema,bytes),
    options: {},
  },
  /**
   * Single commit offset request.
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.CommitOffset
   */
  commitOffset: {
    path: "/Ydb.Topic.V1.TopicService/CommitOffset",
    requestStream: false,
    requestSerialize: (message: MessageInitShape<typeof CommitOffsetRequestSchema>) => toBinary(CommitOffsetRequestSchema, create(CommitOffsetRequestSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(CommitOffsetRequestSchema,bytes),
      responseStream: false, 
    responseSerialize: (message: MessageInitShape<typeof CommitOffsetResponseSchema>) => toBinary(CommitOffsetResponseSchema, create(CommitOffsetResponseSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(CommitOffsetResponseSchema,bytes),
    options: {},
  },
  /**
   * Add information about offset ranges to the transaction.
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.UpdateOffsetsInTransaction
   */
  updateOffsetsInTransaction: {
    path: "/Ydb.Topic.V1.TopicService/UpdateOffsetsInTransaction",
    requestStream: false,
    requestSerialize: (message: MessageInitShape<typeof UpdateOffsetsInTransactionRequestSchema>) => toBinary(UpdateOffsetsInTransactionRequestSchema, create(UpdateOffsetsInTransactionRequestSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(UpdateOffsetsInTransactionRequestSchema,bytes),
      responseStream: false, 
    responseSerialize: (message: MessageInitShape<typeof UpdateOffsetsInTransactionResponseSchema>) => toBinary(UpdateOffsetsInTransactionResponseSchema, create(UpdateOffsetsInTransactionResponseSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(UpdateOffsetsInTransactionResponseSchema,bytes),
    options: {},
  },
  /**
   * Create topic command.
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.CreateTopic
   */
  createTopic: {
    path: "/Ydb.Topic.V1.TopicService/CreateTopic",
    requestStream: false,
    requestSerialize: (message: MessageInitShape<typeof CreateTopicRequestSchema>) => toBinary(CreateTopicRequestSchema, create(CreateTopicRequestSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(CreateTopicRequestSchema,bytes),
      responseStream: false, 
    responseSerialize: (message: MessageInitShape<typeof CreateTopicResponseSchema>) => toBinary(CreateTopicResponseSchema, create(CreateTopicResponseSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(CreateTopicResponseSchema,bytes),
    options: {},
  },
  /**
   * Describe topic command.
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.DescribeTopic
   */
  describeTopic: {
    path: "/Ydb.Topic.V1.TopicService/DescribeTopic",
    requestStream: false,
    requestSerialize: (message: MessageInitShape<typeof DescribeTopicRequestSchema>) => toBinary(DescribeTopicRequestSchema, create(DescribeTopicRequestSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(DescribeTopicRequestSchema,bytes),
      responseStream: false, 
    responseSerialize: (message: MessageInitShape<typeof DescribeTopicResponseSchema>) => toBinary(DescribeTopicResponseSchema, create(DescribeTopicResponseSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(DescribeTopicResponseSchema,bytes),
    options: {},
  },
  /**
   * Describe topic's consumer command.
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.DescribeConsumer
   */
  describeConsumer: {
    path: "/Ydb.Topic.V1.TopicService/DescribeConsumer",
    requestStream: false,
    requestSerialize: (message: MessageInitShape<typeof DescribeConsumerRequestSchema>) => toBinary(DescribeConsumerRequestSchema, create(DescribeConsumerRequestSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(DescribeConsumerRequestSchema,bytes),
      responseStream: false, 
    responseSerialize: (message: MessageInitShape<typeof DescribeConsumerResponseSchema>) => toBinary(DescribeConsumerResponseSchema, create(DescribeConsumerResponseSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(DescribeConsumerResponseSchema,bytes),
    options: {},
  },
  /**
   * Alter topic command.
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.AlterTopic
   */
  alterTopic: {
    path: "/Ydb.Topic.V1.TopicService/AlterTopic",
    requestStream: false,
    requestSerialize: (message: MessageInitShape<typeof AlterTopicRequestSchema>) => toBinary(AlterTopicRequestSchema, create(AlterTopicRequestSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(AlterTopicRequestSchema,bytes),
      responseStream: false, 
    responseSerialize: (message: MessageInitShape<typeof AlterTopicResponseSchema>) => toBinary(AlterTopicResponseSchema, create(AlterTopicResponseSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(AlterTopicResponseSchema,bytes),
    options: {},
  },
  /**
   * Drop topic command.
   *
   * @generated from rpc Ydb.Topic.V1.TopicService.DropTopic
   */
  dropTopic: {
    path: "/Ydb.Topic.V1.TopicService/DropTopic",
    requestStream: false,
    requestSerialize: (message: MessageInitShape<typeof DropTopicRequestSchema>) => toBinary(DropTopicRequestSchema, create(DropTopicRequestSchema, message)),
    requestDeserialize: (bytes: Uint8Array) => fromBinary(DropTopicRequestSchema,bytes),
      responseStream: false, 
    responseSerialize: (message: MessageInitShape<typeof DropTopicResponseSchema>) => toBinary(DropTopicResponseSchema, create(DropTopicResponseSchema, message)),
    responseDeserialize: (bytes: Uint8Array) => fromBinary(DropTopicResponseSchema,bytes),
    options: {},
  },
} as const satisfies ServiceDefinition
