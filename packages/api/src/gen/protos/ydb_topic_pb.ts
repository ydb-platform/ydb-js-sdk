// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=js"
// @generated from file protos/ydb_topic.proto (package Ydb.Topic, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Operation, OperationParams } from "./ydb_operation_pb.js";
import { file_protos_ydb_operation } from "./ydb_operation_pb.js";
import type { Entry } from "./ydb_scheme_pb.js";
import { file_protos_ydb_scheme } from "./ydb_scheme_pb.js";
import type { StatusIds_StatusCode } from "./ydb_status_codes_pb.js";
import { file_protos_ydb_status_codes } from "./ydb_status_codes_pb.js";
import type { IssueMessage } from "./ydb_issue_message_pb.js";
import { file_protos_ydb_issue_message } from "./ydb_issue_message_pb.js";
import { file_protos_annotations_sensitive } from "./annotations/sensitive_pb.js";
import { file_protos_annotations_validation } from "./annotations/validation_pb.js";
import type { Duration } from "../google/protobuf/duration_pb.js";
import { file_google_protobuf_duration } from "../google/protobuf/duration_pb.js";
import type { Timestamp } from "../google/protobuf/timestamp_pb.js";
import { file_google_protobuf_timestamp } from "../google/protobuf/timestamp_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file protos/ydb_topic.proto.
 */
export const file_protos_ydb_topic: GenFile = /*@__PURE__*/
  fileDesc("ChZwcm90b3MveWRiX3RvcGljLnByb3RvEglZZGIuVG9waWMiNwoPU3VwcG9ydGVkQ29kZWNzEiQKBmNvZGVjcxgBIAMoBUIUmuYqAhhksuYqClsxOyAxOTk5OV0iKgoMT2Zmc2V0c1JhbmdlEg0KBXN0YXJ0GAEgASgDEgsKA2VuZBgCIAEoAyIpChJVcGRhdGVUb2tlblJlcXVlc3QSEwoFdG9rZW4YASABKAlCBLjmKgEiFQoTVXBkYXRlVG9rZW5SZXNwb25zZSJDChdQYXJ0aXRpb25XaXRoR2VuZXJhdGlvbhIUCgxwYXJ0aXRpb25faWQYASABKAMSEgoKZ2VuZXJhdGlvbhgCIAEoAyIqCgxNZXRhZGF0YUl0ZW0SCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgMIp4UChJTdHJlYW1Xcml0ZU1lc3NhZ2Ua5QEKCkZyb21DbGllbnQSQQoMaW5pdF9yZXF1ZXN0GAEgASgLMikuWWRiLlRvcGljLlN0cmVhbVdyaXRlTWVzc2FnZS5Jbml0UmVxdWVzdEgAEkMKDXdyaXRlX3JlcXVlc3QYAiABKAsyKi5ZZGIuVG9waWMuU3RyZWFtV3JpdGVNZXNzYWdlLldyaXRlUmVxdWVzdEgAEj0KFHVwZGF0ZV90b2tlbl9yZXF1ZXN0GAMgASgLMh0uWWRiLlRvcGljLlVwZGF0ZVRva2VuUmVxdWVzdEgAQhAKDmNsaWVudF9tZXNzYWdlGr8CCgpGcm9tU2VydmVyEikKBnN0YXR1cxgBIAEoDjIZLllkYi5TdGF0dXNJZHMuU3RhdHVzQ29kZRInCgZpc3N1ZXMYAiADKAsyFy5ZZGIuSXNzdWUuSXNzdWVNZXNzYWdlEkMKDWluaXRfcmVzcG9uc2UYAyABKAsyKi5ZZGIuVG9waWMuU3RyZWFtV3JpdGVNZXNzYWdlLkluaXRSZXNwb25zZUgAEkUKDndyaXRlX3Jlc3BvbnNlGAQgASgLMisuWWRiLlRvcGljLlN0cmVhbVdyaXRlTWVzc2FnZS5Xcml0ZVJlc3BvbnNlSAASPwoVdXBkYXRlX3Rva2VuX3Jlc3BvbnNlGAUgASgLMh4uWWRiLlRvcGljLlVwZGF0ZVRva2VuUmVzcG9uc2VIAEIQCg5zZXJ2ZXJfbWVzc2FnZRr+AgoLSW5pdFJlcXVlc3QSDAoEcGF0aBgBIAEoCRIcCgtwcm9kdWNlcl9pZBgCIAEoCUIHouYqAxiAEBJbChJ3cml0ZV9zZXNzaW9uX21ldGEYAyADKAsyPy5ZZGIuVG9waWMuU3RyZWFtV3JpdGVNZXNzYWdlLkluaXRSZXF1ZXN0LldyaXRlU2Vzc2lvbk1ldGFFbnRyeRIjChBtZXNzYWdlX2dyb3VwX2lkGAQgASgJQgei5ioDGIAQSAASFgoMcGFydGl0aW9uX2lkGAUgASgDSAASRwoZcGFydGl0aW9uX3dpdGhfZ2VuZXJhdGlvbhgHIAEoCzIiLllkYi5Ub3BpYy5QYXJ0aXRpb25XaXRoR2VuZXJhdGlvbkgAEhcKD2dldF9sYXN0X3NlcV9ubxgGIAEoCBo3ChVXcml0ZVNlc3Npb25NZXRhRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIOCgxwYXJ0aXRpb25pbmcagwEKDEluaXRSZXNwb25zZRITCgtsYXN0X3NlcV9ubxgBIAEoAxISCgpzZXNzaW9uX2lkGAIgASgJEhQKDHBhcnRpdGlvbl9pZBgDIAEoAxI0ChBzdXBwb3J0ZWRfY29kZWNzGAQgASgLMhouWWRiLlRvcGljLlN1cHBvcnRlZENvZGVjcxroAwoMV3JpdGVSZXF1ZXN0EkgKCG1lc3NhZ2VzGAEgAygLMjYuWWRiLlRvcGljLlN0cmVhbVdyaXRlTWVzc2FnZS5Xcml0ZVJlcXVlc3QuTWVzc2FnZURhdGESDQoFY29kZWMYAiABKAUSLwoCdHgYAyABKAsyHi5ZZGIuVG9waWMuVHJhbnNhY3Rpb25JZGVudGl0eUgAiAEBGsYCCgtNZXNzYWdlRGF0YRIOCgZzZXFfbm8YASABKAMSLgoKY3JlYXRlZF9hdBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDAoEZGF0YRgDIAEoDBIZChF1bmNvbXByZXNzZWRfc2l6ZRgEIAEoAxIjChBtZXNzYWdlX2dyb3VwX2lkGAUgASgJQgei5ioDGIAQSAASFgoMcGFydGl0aW9uX2lkGAYgASgDSAASRwoZcGFydGl0aW9uX3dpdGhfZ2VuZXJhdGlvbhgIIAEoCzIiLllkYi5Ub3BpYy5QYXJ0aXRpb25XaXRoR2VuZXJhdGlvbkgAEjgKDm1ldGFkYXRhX2l0ZW1zGAcgAygLMhcuWWRiLlRvcGljLk1ldGFkYXRhSXRlbUIHmuYqAxjoB0IOCgxwYXJ0aXRpb25pbmdCBQoDX3R4GusHCg1Xcml0ZVJlc3BvbnNlEkIKBGFja3MYASADKAsyNC5ZZGIuVG9waWMuU3RyZWFtV3JpdGVNZXNzYWdlLldyaXRlUmVzcG9uc2UuV3JpdGVBY2sSFAoMcGFydGl0aW9uX2lkGAIgASgDElUKEHdyaXRlX3N0YXRpc3RpY3MYAyABKAsyOy5ZZGIuVG9waWMuU3RyZWFtV3JpdGVNZXNzYWdlLldyaXRlUmVzcG9uc2UuV3JpdGVTdGF0aXN0aWNzGvgDCghXcml0ZUFjaxIOCgZzZXFfbm8YASABKAMSTwoHd3JpdHRlbhgCIAEoCzI8LllkYi5Ub3BpYy5TdHJlYW1Xcml0ZU1lc3NhZ2UuV3JpdGVSZXNwb25zZS5Xcml0ZUFjay5Xcml0dGVuSAASTwoHc2tpcHBlZBgDIAEoCzI8LllkYi5Ub3BpYy5TdHJlYW1Xcml0ZU1lc3NhZ2UuV3JpdGVSZXNwb25zZS5Xcml0ZUFjay5Ta2lwcGVkSAASWQoNd3JpdHRlbl9pbl90eBgEIAEoCzJALllkYi5Ub3BpYy5TdHJlYW1Xcml0ZU1lc3NhZ2UuV3JpdGVSZXNwb25zZS5Xcml0ZUFjay5Xcml0dGVuSW5UeEgAGhkKB1dyaXR0ZW4SDgoGb2Zmc2V0GAEgASgDGpwBCgdTa2lwcGVkElMKBnJlYXNvbhgBIAEoDjJDLllkYi5Ub3BpYy5TdHJlYW1Xcml0ZU1lc3NhZ2UuV3JpdGVSZXNwb25zZS5Xcml0ZUFjay5Ta2lwcGVkLlJlYXNvbiI8CgZSZWFzb24SFgoSUkVBU09OX1VOU1BFQ0lGSUVEEAASGgoWUkVBU09OX0FMUkVBRFlfV1JJVFRFThABGg0KC1dyaXR0ZW5JblR4QhYKFG1lc3NhZ2Vfd3JpdGVfc3RhdHVzGq0CCg9Xcml0ZVN0YXRpc3RpY3MSMgoPcGVyc2lzdGluZ190aW1lGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjYKE21pbl9xdWV1ZV93YWl0X3RpbWUYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SNgoTbWF4X3F1ZXVlX3dhaXRfdGltZRgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI8ChlwYXJ0aXRpb25fcXVvdGFfd2FpdF90aW1lGAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjgKFXRvcGljX3F1b3RhX3dhaXRfdGltZRgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbiKcIwoRU3RyZWFtUmVhZE1lc3NhZ2UaVAoQUGFydGl0aW9uU2Vzc2lvbhIcChRwYXJ0aXRpb25fc2Vzc2lvbl9pZBgBIAEoAxIMCgRwYXRoGAIgASgJEhQKDHBhcnRpdGlvbl9pZBgDIAEoAxqxBQoKRnJvbUNsaWVudBJACgxpbml0X3JlcXVlc3QYASABKAsyKC5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuSW5pdFJlcXVlc3RIABJACgxyZWFkX3JlcXVlc3QYAiABKAsyKC5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuUmVhZFJlcXVlc3RIABJRChVjb21taXRfb2Zmc2V0X3JlcXVlc3QYAyABKAsyMC5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuQ29tbWl0T2Zmc2V0UmVxdWVzdEgAEmYKIHBhcnRpdGlvbl9zZXNzaW9uX3N0YXR1c19yZXF1ZXN0GAQgASgLMjouWWRiLlRvcGljLlN0cmVhbVJlYWRNZXNzYWdlLlBhcnRpdGlvblNlc3Npb25TdGF0dXNSZXF1ZXN0SAASPQoUdXBkYXRlX3Rva2VuX3JlcXVlc3QYBSABKAsyHS5ZZGIuVG9waWMuVXBkYXRlVG9rZW5SZXF1ZXN0SAASRQoPZGlyZWN0X3JlYWRfYWNrGAggASgLMiouWWRiLlRvcGljLlN0cmVhbVJlYWRNZXNzYWdlLkRpcmVjdFJlYWRBY2tIABJmCiBzdGFydF9wYXJ0aXRpb25fc2Vzc2lvbl9yZXNwb25zZRgGIAEoCzI6LllkYi5Ub3BpYy5TdHJlYW1SZWFkTWVzc2FnZS5TdGFydFBhcnRpdGlvblNlc3Npb25SZXNwb25zZUgAEmQKH3N0b3BfcGFydGl0aW9uX3Nlc3Npb25fcmVzcG9uc2UYByABKAsyOS5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuU3RvcFBhcnRpdGlvblNlc3Npb25SZXNwb25zZUgAQhAKDmNsaWVudF9tZXNzYWdlGvAGCgpGcm9tU2VydmVyEikKBnN0YXR1cxgBIAEoDjIZLllkYi5TdGF0dXNJZHMuU3RhdHVzQ29kZRInCgZpc3N1ZXMYAiADKAsyFy5ZZGIuSXNzdWUuSXNzdWVNZXNzYWdlEkIKDWluaXRfcmVzcG9uc2UYAyABKAsyKS5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuSW5pdFJlc3BvbnNlSAASQgoNcmVhZF9yZXNwb25zZRgEIAEoCzIpLllkYi5Ub3BpYy5TdHJlYW1SZWFkTWVzc2FnZS5SZWFkUmVzcG9uc2VIABJTChZjb21taXRfb2Zmc2V0X3Jlc3BvbnNlGAUgASgLMjEuWWRiLlRvcGljLlN0cmVhbVJlYWRNZXNzYWdlLkNvbW1pdE9mZnNldFJlc3BvbnNlSAASaAohcGFydGl0aW9uX3Nlc3Npb25fc3RhdHVzX3Jlc3BvbnNlGAYgASgLMjsuWWRiLlRvcGljLlN0cmVhbVJlYWRNZXNzYWdlLlBhcnRpdGlvblNlc3Npb25TdGF0dXNSZXNwb25zZUgAEj8KFXVwZGF0ZV90b2tlbl9yZXNwb25zZRgHIAEoCzIeLllkYi5Ub3BpYy5VcGRhdGVUb2tlblJlc3BvbnNlSAASZAofc3RhcnRfcGFydGl0aW9uX3Nlc3Npb25fcmVxdWVzdBgIIAEoCzI5LllkYi5Ub3BpYy5TdHJlYW1SZWFkTWVzc2FnZS5TdGFydFBhcnRpdGlvblNlc3Npb25SZXF1ZXN0SAASYgoec3RvcF9wYXJ0aXRpb25fc2Vzc2lvbl9yZXF1ZXN0GAkgASgLMjguWWRiLlRvcGljLlN0cmVhbVJlYWRNZXNzYWdlLlN0b3BQYXJ0aXRpb25TZXNzaW9uUmVxdWVzdEgAElcKGHVwZGF0ZV9wYXJ0aXRpb25fc2Vzc2lvbhgKIAEoCzIzLllkYi5Ub3BpYy5TdHJlYW1SZWFkTWVzc2FnZS5VcGRhdGVQYXJ0aXRpb25TZXNzaW9uSAASUQoVZW5kX3BhcnRpdGlvbl9zZXNzaW9uGAsgASgLMjAuWWRiLlRvcGljLlN0cmVhbVJlYWRNZXNzYWdlLkVuZFBhcnRpdGlvblNlc3Npb25IAEIQCg5zZXJ2ZXJfbWVzc2FnZRrcAgoLSW5pdFJlcXVlc3QSWAoUdG9waWNzX3JlYWRfc2V0dGluZ3MYASADKAsyOi5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuSW5pdFJlcXVlc3QuVG9waWNSZWFkU2V0dGluZ3MSEAoIY29uc3VtZXIYAiABKAkSEwoLcmVhZGVyX25hbWUYAyABKAkSEwoLZGlyZWN0X3JlYWQYBCABKAgSIQoZYXV0b19wYXJ0aXRpb25pbmdfc3VwcG9ydBgFIAEoCBqTAQoRVG9waWNSZWFkU2V0dGluZ3MSDAoEcGF0aBgBIAEoCRIVCg1wYXJ0aXRpb25faWRzGAIgAygDEioKB21heF9sYWcYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SLQoJcmVhZF9mcm9tGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBoiCgxJbml0UmVzcG9uc2USEgoKc2Vzc2lvbl9pZBgBIAEoCRohCgtSZWFkUmVxdWVzdBISCgpieXRlc19zaXplGAEgASgDGpEGCgxSZWFkUmVzcG9uc2USTwoOcGFydGl0aW9uX2RhdGEYASADKAsyNy5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuUmVhZFJlc3BvbnNlLlBhcnRpdGlvbkRhdGESEgoKYnl0ZXNfc2l6ZRgCIAEoAxraAQoLTWVzc2FnZURhdGESDgoGb2Zmc2V0GAEgASgDEg4KBnNlcV9ubxgCIAEoAxIuCgpjcmVhdGVkX2F0GAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIMCgRkYXRhGAUgASgMEhkKEXVuY29tcHJlc3NlZF9zaXplGAYgASgDEiEKEG1lc3NhZ2VfZ3JvdXBfaWQYByABKAlCB6LmKgMYgBASLwoObWV0YWRhdGFfaXRlbXMYCCADKAsyFy5ZZGIuVG9waWMuTWV0YWRhdGFJdGVtGs0CCgVCYXRjaBJLCgxtZXNzYWdlX2RhdGEYASADKAsyNS5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuUmVhZFJlc3BvbnNlLk1lc3NhZ2VEYXRhEhwKC3Byb2R1Y2VyX2lkGAIgASgJQgei5ioDGIAQEmEKEndyaXRlX3Nlc3Npb25fbWV0YRgDIAMoCzJFLllkYi5Ub3BpYy5TdHJlYW1SZWFkTWVzc2FnZS5SZWFkUmVzcG9uc2UuQmF0Y2guV3JpdGVTZXNzaW9uTWV0YUVudHJ5Eg0KBWNvZGVjGAQgASgFEi4KCndyaXR0ZW5fYXQYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wGjcKFVdyaXRlU2Vzc2lvbk1ldGFFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGm8KDVBhcnRpdGlvbkRhdGESHAoUcGFydGl0aW9uX3Nlc3Npb25faWQYASABKAMSQAoHYmF0Y2hlcxgCIAMoCzIvLllkYi5Ub3BpYy5TdHJlYW1SZWFkTWVzc2FnZS5SZWFkUmVzcG9uc2UuQmF0Y2ga1gEKE0NvbW1pdE9mZnNldFJlcXVlc3QSXgoOY29tbWl0X29mZnNldHMYASADKAsyRi5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuQ29tbWl0T2Zmc2V0UmVxdWVzdC5QYXJ0aXRpb25Db21taXRPZmZzZXQaXwoVUGFydGl0aW9uQ29tbWl0T2Zmc2V0EhwKFHBhcnRpdGlvbl9zZXNzaW9uX2lkGAEgASgDEigKB29mZnNldHMYAiADKAsyFy5ZZGIuVG9waWMuT2Zmc2V0c1JhbmdlGtwBChRDb21taXRPZmZzZXRSZXNwb25zZRJwChxwYXJ0aXRpb25zX2NvbW1pdHRlZF9vZmZzZXRzGAEgAygLMkouWWRiLlRvcGljLlN0cmVhbVJlYWRNZXNzYWdlLkNvbW1pdE9mZnNldFJlc3BvbnNlLlBhcnRpdGlvbkNvbW1pdHRlZE9mZnNldBpSChhQYXJ0aXRpb25Db21taXR0ZWRPZmZzZXQSHAoUcGFydGl0aW9uX3Nlc3Npb25faWQYASABKAMSGAoQY29tbWl0dGVkX29mZnNldBgCIAEoAxo9Ch1QYXJ0aXRpb25TZXNzaW9uU3RhdHVzUmVxdWVzdBIcChRwYXJ0aXRpb25fc2Vzc2lvbl9pZBgBIAEoAxrLAQoeUGFydGl0aW9uU2Vzc2lvblN0YXR1c1Jlc3BvbnNlEhwKFHBhcnRpdGlvbl9zZXNzaW9uX2lkGAEgASgDEjIKEXBhcnRpdGlvbl9vZmZzZXRzGAIgASgLMhcuWWRiLlRvcGljLk9mZnNldHNSYW5nZRIYChBjb21taXR0ZWRfb2Zmc2V0GAMgASgDEj0KGXdyaXRlX3RpbWVfaGlnaF93YXRlcm1hcmsYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wGvABChxTdGFydFBhcnRpdGlvblNlc3Npb25SZXF1ZXN0EkgKEXBhcnRpdGlvbl9zZXNzaW9uGAEgASgLMi0uWWRiLlRvcGljLlN0cmVhbVJlYWRNZXNzYWdlLlBhcnRpdGlvblNlc3Npb24SGAoQY29tbWl0dGVkX29mZnNldBgCIAEoAxIyChFwYXJ0aXRpb25fb2Zmc2V0cxgDIAEoCzIXLllkYi5Ub3BpYy5PZmZzZXRzUmFuZ2USOAoScGFydGl0aW9uX2xvY2F0aW9uGAQgASgLMhwuWWRiLlRvcGljLlBhcnRpdGlvbkxvY2F0aW9uGpUBCh1TdGFydFBhcnRpdGlvblNlc3Npb25SZXNwb25zZRIcChRwYXJ0aXRpb25fc2Vzc2lvbl9pZBgBIAEoAxIYCgtyZWFkX29mZnNldBgCIAEoA0gAiAEBEhoKDWNvbW1pdF9vZmZzZXQYAyABKANIAYgBAUIOCgxfcmVhZF9vZmZzZXRCEAoOX2NvbW1pdF9vZmZzZXQahAEKG1N0b3BQYXJ0aXRpb25TZXNzaW9uUmVxdWVzdBIcChRwYXJ0aXRpb25fc2Vzc2lvbl9pZBgBIAEoAxIQCghncmFjZWZ1bBgCIAEoCBIYChBjb21taXR0ZWRfb2Zmc2V0GAMgASgDEhsKE2xhc3RfZGlyZWN0X3JlYWRfaWQYBCABKAMaTgocU3RvcFBhcnRpdGlvblNlc3Npb25SZXNwb25zZRIcChRwYXJ0aXRpb25fc2Vzc2lvbl9pZBgBIAEoAxIQCghncmFjZWZ1bBgCIAEoCBpwChZVcGRhdGVQYXJ0aXRpb25TZXNzaW9uEhwKFHBhcnRpdGlvbl9zZXNzaW9uX2lkGAEgASgDEjgKEnBhcnRpdGlvbl9sb2NhdGlvbhgCIAEoCzIcLllkYi5Ub3BpYy5QYXJ0aXRpb25Mb2NhdGlvbhpFCg1EaXJlY3RSZWFkQWNrEhwKFHBhcnRpdGlvbl9zZXNzaW9uX2lkGAEgASgDEhYKDmRpcmVjdF9yZWFkX2lkGAIgASgDGnAKE0VuZFBhcnRpdGlvblNlc3Npb24SHAoUcGFydGl0aW9uX3Nlc3Npb25faWQYASABKAMSHgoWYWRqYWNlbnRfcGFydGl0aW9uX2lkcxgCIAMoAxIbChNjaGlsZF9wYXJ0aXRpb25faWRzGAMgAygDIvcMChdTdHJlYW1EaXJlY3RSZWFkTWVzc2FnZRqoAgoKRnJvbUNsaWVudBJGCgxpbml0X3JlcXVlc3QYASABKAsyLi5ZZGIuVG9waWMuU3RyZWFtRGlyZWN0UmVhZE1lc3NhZ2UuSW5pdFJlcXVlc3RIABKAAQorc3RhcnRfZGlyZWN0X3JlYWRfcGFydGl0aW9uX3Nlc3Npb25fcmVxdWVzdBgCIAEoCzJJLllkYi5Ub3BpYy5TdHJlYW1EaXJlY3RSZWFkTWVzc2FnZS5TdGFydERpcmVjdFJlYWRQYXJ0aXRpb25TZXNzaW9uUmVxdWVzdEgAEj0KFHVwZGF0ZV90b2tlbl9yZXF1ZXN0GAMgASgLMh0uWWRiLlRvcGljLlVwZGF0ZVRva2VuUmVxdWVzdEgAQhAKDmNsaWVudF9tZXNzYWdlGsoECgpGcm9tU2VydmVyEikKBnN0YXR1cxgBIAEoDjIZLllkYi5TdGF0dXNJZHMuU3RhdHVzQ29kZRInCgZpc3N1ZXMYAiADKAsyFy5ZZGIuSXNzdWUuSXNzdWVNZXNzYWdlEkgKDWluaXRfcmVzcG9uc2UYBiABKAsyLy5ZZGIuVG9waWMuU3RyZWFtRGlyZWN0UmVhZE1lc3NhZ2UuSW5pdFJlc3BvbnNlSAASggEKLHN0YXJ0X2RpcmVjdF9yZWFkX3BhcnRpdGlvbl9zZXNzaW9uX3Jlc3BvbnNlGAcgASgLMkouWWRiLlRvcGljLlN0cmVhbURpcmVjdFJlYWRNZXNzYWdlLlN0YXJ0RGlyZWN0UmVhZFBhcnRpdGlvblNlc3Npb25SZXNwb25zZUgAEm8KInN0b3BfZGlyZWN0X3JlYWRfcGFydGl0aW9uX3Nlc3Npb24YAyABKAsyQS5ZZGIuVG9waWMuU3RyZWFtRGlyZWN0UmVhZE1lc3NhZ2UuU3RvcERpcmVjdFJlYWRQYXJ0aXRpb25TZXNzaW9uSAASVQoUZGlyZWN0X3JlYWRfcmVzcG9uc2UYBCABKAsyNS5ZZGIuVG9waWMuU3RyZWFtRGlyZWN0UmVhZE1lc3NhZ2UuRGlyZWN0UmVhZFJlc3BvbnNlSAASPwoVdXBkYXRlX3Rva2VuX3Jlc3BvbnNlGAUgASgLMh4uWWRiLlRvcGljLlVwZGF0ZVRva2VuUmVzcG9uc2VIAEIQCg5zZXJ2ZXJfbWVzc2FnZRq2AQoLSW5pdFJlcXVlc3QSEgoKc2Vzc2lvbl9pZBgBIAEoCRJeChR0b3BpY3NfcmVhZF9zZXR0aW5ncxgCIAMoCzJALllkYi5Ub3BpYy5TdHJlYW1EaXJlY3RSZWFkTWVzc2FnZS5Jbml0UmVxdWVzdC5Ub3BpY1JlYWRTZXR0aW5ncxIQCghjb25zdW1lchgDIAEoCRohChFUb3BpY1JlYWRTZXR0aW5ncxIMCgRwYXRoGAEgASgJGg4KDEluaXRSZXNwb25zZRp3CiZTdGFydERpcmVjdFJlYWRQYXJ0aXRpb25TZXNzaW9uUmVxdWVzdBIcChRwYXJ0aXRpb25fc2Vzc2lvbl9pZBgBIAEoAxIbChNsYXN0X2RpcmVjdF9yZWFkX2lkGAIgASgDEhIKCmdlbmVyYXRpb24YAyABKAMaWwonU3RhcnREaXJlY3RSZWFkUGFydGl0aW9uU2Vzc2lvblJlc3BvbnNlEhwKFHBhcnRpdGlvbl9zZXNzaW9uX2lkGAEgASgDEhIKCmdlbmVyYXRpb24YAiABKAMapgEKHlN0b3BEaXJlY3RSZWFkUGFydGl0aW9uU2Vzc2lvbhIpCgZzdGF0dXMYASABKA4yGS5ZZGIuU3RhdHVzSWRzLlN0YXR1c0NvZGUSJwoGaXNzdWVzGAIgAygLMhcuWWRiLklzc3VlLklzc3VlTWVzc2FnZRIcChRwYXJ0aXRpb25fc2Vzc2lvbl9pZBgDIAEoAxISCgpnZW5lcmF0aW9uGAQgASgDGpsBChJEaXJlY3RSZWFkUmVzcG9uc2USHAoUcGFydGl0aW9uX3Nlc3Npb25faWQYASABKAMSFgoOZGlyZWN0X3JlYWRfaWQYAiABKAMSTwoOcGFydGl0aW9uX2RhdGEYAyABKAsyNy5ZZGIuVG9waWMuU3RyZWFtUmVhZE1lc3NhZ2UuUmVhZFJlc3BvbnNlLlBhcnRpdGlvbkRhdGEiMgoTVHJhbnNhY3Rpb25JZGVudGl0eRIKCgJpZBgBIAEoCRIPCgdzZXNzaW9uGAIgASgJIsQDCiFVcGRhdGVPZmZzZXRzSW5UcmFuc2FjdGlvblJlcXVlc3QSOQoQb3BlcmF0aW9uX3BhcmFtcxgBIAEoCzIfLllkYi5PcGVyYXRpb25zLk9wZXJhdGlvblBhcmFtcxIqCgJ0eBgCIAEoCzIeLllkYi5Ub3BpYy5UcmFuc2FjdGlvbklkZW50aXR5EkkKBnRvcGljcxgDIAMoCzI5LllkYi5Ub3BpYy5VcGRhdGVPZmZzZXRzSW5UcmFuc2FjdGlvblJlcXVlc3QuVG9waWNPZmZzZXRzEhAKCGNvbnN1bWVyGAQgASgJGtoBCgxUb3BpY09mZnNldHMSDAoEcGF0aBgBIAEoCRJeCgpwYXJ0aXRpb25zGAIgAygLMkouWWRiLlRvcGljLlVwZGF0ZU9mZnNldHNJblRyYW5zYWN0aW9uUmVxdWVzdC5Ub3BpY09mZnNldHMuUGFydGl0aW9uT2Zmc2V0cxpcChBQYXJ0aXRpb25PZmZzZXRzEhQKDHBhcnRpdGlvbl9pZBgBIAEoAxIyChFwYXJ0aXRpb25fb2Zmc2V0cxgCIAMoCzIXLllkYi5Ub3BpYy5PZmZzZXRzUmFuZ2UiUgoiVXBkYXRlT2Zmc2V0c0luVHJhbnNhY3Rpb25SZXNwb25zZRIsCglvcGVyYXRpb24YASABKAsyGS5ZZGIuT3BlcmF0aW9ucy5PcGVyYXRpb24iIgogVXBkYXRlT2Zmc2V0c0luVHJhbnNhY3Rpb25SZXN1bHQilgEKE0NvbW1pdE9mZnNldFJlcXVlc3QSOQoQb3BlcmF0aW9uX3BhcmFtcxgBIAEoCzIfLllkYi5PcGVyYXRpb25zLk9wZXJhdGlvblBhcmFtcxIMCgRwYXRoGAIgASgJEhQKDHBhcnRpdGlvbl9pZBgDIAEoAxIQCghjb25zdW1lchgEIAEoCRIOCgZvZmZzZXQYBSABKAMiRAoUQ29tbWl0T2Zmc2V0UmVzcG9uc2USLAoJb3BlcmF0aW9uGAEgASgLMhkuWWRiLk9wZXJhdGlvbnMuT3BlcmF0aW9uIhQKEkNvbW1pdE9mZnNldFJlc3VsdCJMChNNdWx0aXBsZVdpbmRvd3NTdGF0EhIKCnBlcl9taW51dGUYASABKAMSEAoIcGVyX2hvdXIYAiABKAMSDwoHcGVyX2RheRgDIAEoAyKzBAoIQ29uc3VtZXISDAoEbmFtZRgBIAEoCRIRCglpbXBvcnRhbnQYAiABKAgSLQoJcmVhZF9mcm9tGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI0ChBzdXBwb3J0ZWRfY29kZWNzGAUgASgLMhouWWRiLlRvcGljLlN1cHBvcnRlZENvZGVjcxI3CgphdHRyaWJ1dGVzGAYgAygLMiMuWWRiLlRvcGljLkNvbnN1bWVyLkF0dHJpYnV0ZXNFbnRyeRI5Cg5jb25zdW1lcl9zdGF0cxgHIAEoCzIhLllkYi5Ub3BpYy5Db25zdW1lci5Db25zdW1lclN0YXRzGjEKD0F0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGvMBCg1Db25zdW1lclN0YXRzEkEKHW1pbl9wYXJ0aXRpb25zX2xhc3RfcmVhZF90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI0ChFtYXhfcmVhZF90aW1lX2xhZxgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI1ChJtYXhfd3JpdGVfdGltZV9sYWcYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMgoKYnl0ZXNfcmVhZBgEIAEoCzIeLllkYi5Ub3BpYy5NdWx0aXBsZVdpbmRvd3NTdGF0SgQIBBAFIr8CCg1BbHRlckNvbnN1bWVyEgwKBG5hbWUYASABKAkSGgoNc2V0X2ltcG9ydGFudBgCIAEoCEgAiAEBEjEKDXNldF9yZWFkX2Zyb20YAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjgKFHNldF9zdXBwb3J0ZWRfY29kZWNzGAUgASgLMhouWWRiLlRvcGljLlN1cHBvcnRlZENvZGVjcxJHChBhbHRlcl9hdHRyaWJ1dGVzGAYgAygLMi0uWWRiLlRvcGljLkFsdGVyQ29uc3VtZXIuQWx0ZXJBdHRyaWJ1dGVzRW50cnkaNgoUQWx0ZXJBdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIQCg5fc2V0X2ltcG9ydGFudEoECAQQBSLcAQoUUGFydGl0aW9uaW5nU2V0dGluZ3MSJwoVbWluX2FjdGl2ZV9wYXJ0aXRpb25zGAEgASgDQgiy5ioEPj0gMBInChVtYXhfYWN0aXZlX3BhcnRpdGlvbnMYAyABKANCCLLmKgQ+PSAwEikKFXBhcnRpdGlvbl9jb3VudF9saW1pdBgCIAEoA0IKGAGy5ioEPj0gMBJHChphdXRvX3BhcnRpdGlvbmluZ19zZXR0aW5ncxgEIAEoCzIjLllkYi5Ub3BpYy5BdXRvUGFydGl0aW9uaW5nU2V0dGluZ3MinwEKGEF1dG9QYXJ0aXRpb25pbmdTZXR0aW5ncxI1CghzdHJhdGVneRgBIAEoDjIjLllkYi5Ub3BpYy5BdXRvUGFydGl0aW9uaW5nU3RyYXRlZ3kSTAoVcGFydGl0aW9uX3dyaXRlX3NwZWVkGAIgASgLMi0uWWRiLlRvcGljLkF1dG9QYXJ0aXRpb25pbmdXcml0ZVNwZWVkU3RyYXRlZ3kiswEKIkF1dG9QYXJ0aXRpb25pbmdXcml0ZVNwZWVkU3RyYXRlZ3kSNwoUc3RhYmlsaXphdGlvbl93aW5kb3cYASABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SKAoWdXBfdXRpbGl6YXRpb25fcGVyY2VudBgCIAEoBUIIsuYqBD49IDASKgoYZG93bl91dGlsaXphdGlvbl9wZXJjZW50GAMgASgFQgiy5ioEPj0gMCKLAwoZQWx0ZXJQYXJ0aXRpb25pbmdTZXR0aW5ncxIwChlzZXRfbWluX2FjdGl2ZV9wYXJ0aXRpb25zGAEgASgDQgiy5ioEPj0gMEgAiAEBEjAKGXNldF9tYXhfYWN0aXZlX3BhcnRpdGlvbnMYAyABKANCCLLmKgQ+PSAwSAGIAQESMgoZc2V0X3BhcnRpdGlvbl9jb3VudF9saW1pdBgCIAEoA0IKGAGy5ioEPj0gMEgCiAEBElcKIGFsdGVyX2F1dG9fcGFydGl0aW9uaW5nX3NldHRpbmdzGAQgASgLMiguWWRiLlRvcGljLkFsdGVyQXV0b1BhcnRpdGlvbmluZ1NldHRpbmdzSAOIAQFCHAoaX3NldF9taW5fYWN0aXZlX3BhcnRpdGlvbnNCHAoaX3NldF9tYXhfYWN0aXZlX3BhcnRpdGlvbnNCHAoaX3NldF9wYXJ0aXRpb25fY291bnRfbGltaXRCIwohX2FsdGVyX2F1dG9fcGFydGl0aW9uaW5nX3NldHRpbmdzIuoBCh1BbHRlckF1dG9QYXJ0aXRpb25pbmdTZXR0aW5ncxI+CgxzZXRfc3RyYXRlZ3kYASABKA4yIy5ZZGIuVG9waWMuQXV0b1BhcnRpdGlvbmluZ1N0cmF0ZWd5SACIAQESWgoZc2V0X3BhcnRpdGlvbl93cml0ZV9zcGVlZBgCIAEoCzIyLllkYi5Ub3BpYy5BbHRlckF1dG9QYXJ0aXRpb25pbmdXcml0ZVNwZWVkU3RyYXRlZ3lIAYgBAUIPCg1fc2V0X3N0cmF0ZWd5QhwKGl9zZXRfcGFydGl0aW9uX3dyaXRlX3NwZWVkIrACCidBbHRlckF1dG9QYXJ0aXRpb25pbmdXcml0ZVNwZWVkU3RyYXRlZ3kSQAoYc2V0X3N0YWJpbGl6YXRpb25fd2luZG93GAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uSACIAQESMQoac2V0X3VwX3V0aWxpemF0aW9uX3BlcmNlbnQYAiABKAVCCLLmKgQ+PSAwSAGIAQESMwocc2V0X2Rvd25fdXRpbGl6YXRpb25fcGVyY2VudBgDIAEoBUIIsuYqBD49IDBIAogBAUIbChlfc2V0X3N0YWJpbGl6YXRpb25fd2luZG93Qh0KG19zZXRfdXBfdXRpbGl6YXRpb25fcGVyY2VudEIfCh1fc2V0X2Rvd25fdXRpbGl6YXRpb25fcGVyY2VudCL2BAoSQ3JlYXRlVG9waWNSZXF1ZXN0EjkKEG9wZXJhdGlvbl9wYXJhbXMYASABKAsyHy5ZZGIuT3BlcmF0aW9ucy5PcGVyYXRpb25QYXJhbXMSDAoEcGF0aBgCIAEoCRI+ChVwYXJ0aXRpb25pbmdfc2V0dGluZ3MYAyABKAsyHy5ZZGIuVG9waWMuUGFydGl0aW9uaW5nU2V0dGluZ3MSMwoQcmV0ZW50aW9uX3BlcmlvZBgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhImChRyZXRlbnRpb25fc3RvcmFnZV9tYhgFIAEoA0IIsuYqBD49IDASNAoQc3VwcG9ydGVkX2NvZGVjcxgHIAEoCzIaLllkYi5Ub3BpYy5TdXBwb3J0ZWRDb2RlY3MSOAomcGFydGl0aW9uX3dyaXRlX3NwZWVkX2J5dGVzX3Blcl9zZWNvbmQYCCABKANCCLLmKgQ+PSAwEi0KG3BhcnRpdGlvbl93cml0ZV9idXJzdF9ieXRlcxgJIAEoA0IIsuYqBD49IDASQQoKYXR0cmlidXRlcxgKIAMoCzItLllkYi5Ub3BpYy5DcmVhdGVUb3BpY1JlcXVlc3QuQXR0cmlidXRlc0VudHJ5Ei8KCWNvbnN1bWVycxgLIAMoCzITLllkYi5Ub3BpYy5Db25zdW1lckIHmuYqAxi4FxIuCg1tZXRlcmluZ19tb2RlGAwgASgOMhcuWWRiLlRvcGljLk1ldGVyaW5nTW9kZRoxCg9BdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUoECAYQByJDChNDcmVhdGVUb3BpY1Jlc3BvbnNlEiwKCW9wZXJhdGlvbhgBIAEoCzIZLllkYi5PcGVyYXRpb25zLk9wZXJhdGlvbiITChFDcmVhdGVUb3BpY1Jlc3VsdCI4ChFQYXJ0aXRpb25Mb2NhdGlvbhIPCgdub2RlX2lkGAEgASgFEhIKCmdlbmVyYXRpb24YAiABKAMikAEKFERlc2NyaWJlVG9waWNSZXF1ZXN0EjkKEG9wZXJhdGlvbl9wYXJhbXMYASABKAsyHy5ZZGIuT3BlcmF0aW9ucy5PcGVyYXRpb25QYXJhbXMSDAoEcGF0aBgCIAEoCRIVCg1pbmNsdWRlX3N0YXRzGAMgASgIEhgKEGluY2x1ZGVfbG9jYXRpb24YBCABKAgiRQoVRGVzY3JpYmVUb3BpY1Jlc3BvbnNlEiwKCW9wZXJhdGlvbhgBIAEoCzIZLllkYi5PcGVyYXRpb25zLk9wZXJhdGlvbiJfChFQYXJ0aXRpb25LZXlSYW5nZRIXCgpmcm9tX2JvdW5kGAEgASgMSACIAQESFQoIdG9fYm91bmQYAiABKAxIAYgBAUINCgtfZnJvbV9ib3VuZEILCglfdG9fYm91bmQi+gkKE0Rlc2NyaWJlVG9waWNSZXN1bHQSHwoEc2VsZhgBIAEoCzIRLllkYi5TY2hlbWUuRW50cnkSPgoVcGFydGl0aW9uaW5nX3NldHRpbmdzGAIgASgLMh8uWWRiLlRvcGljLlBhcnRpdGlvbmluZ1NldHRpbmdzEkAKCnBhcnRpdGlvbnMYAyADKAsyLC5ZZGIuVG9waWMuRGVzY3JpYmVUb3BpY1Jlc3VsdC5QYXJ0aXRpb25JbmZvEjMKEHJldGVudGlvbl9wZXJpb2QYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SHAoUcmV0ZW50aW9uX3N0b3JhZ2VfbWIYBSABKAMSNAoQc3VwcG9ydGVkX2NvZGVjcxgHIAEoCzIaLllkYi5Ub3BpYy5TdXBwb3J0ZWRDb2RlY3MSLgomcGFydGl0aW9uX3dyaXRlX3NwZWVkX2J5dGVzX3Blcl9zZWNvbmQYCCABKAMSMworcGFydGl0aW9uX3RvdGFsX3JlYWRfc3BlZWRfYnl0ZXNfcGVyX3NlY29uZBgOIAEoAxI2Ci5wYXJ0aXRpb25fY29uc3VtZXJfcmVhZF9zcGVlZF9ieXRlc19wZXJfc2Vjb25kGA8gASgDEiMKG3BhcnRpdGlvbl93cml0ZV9idXJzdF9ieXRlcxgJIAEoAxJCCgphdHRyaWJ1dGVzGAogAygLMi4uWWRiLlRvcGljLkRlc2NyaWJlVG9waWNSZXN1bHQuQXR0cmlidXRlc0VudHJ5EiYKCWNvbnN1bWVycxgLIAMoCzITLllkYi5Ub3BpYy5Db25zdW1lchIuCg1tZXRlcmluZ19tb2RlGAwgASgOMhcuWWRiLlRvcGljLk1ldGVyaW5nTW9kZRI+Cgt0b3BpY19zdGF0cxgNIAEoCzIpLllkYi5Ub3BpYy5EZXNjcmliZVRvcGljUmVzdWx0LlRvcGljU3RhdHMaMQoPQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEajwIKDVBhcnRpdGlvbkluZm8SFAoMcGFydGl0aW9uX2lkGAEgASgDEg4KBmFjdGl2ZRgCIAEoCBIbChNjaGlsZF9wYXJ0aXRpb25faWRzGAMgAygDEhwKFHBhcmVudF9wYXJ0aXRpb25faWRzGAQgAygDEjIKD3BhcnRpdGlvbl9zdGF0cxgFIAEoCzIZLllkYi5Ub3BpYy5QYXJ0aXRpb25TdGF0cxI4ChJwYXJ0aXRpb25fbG9jYXRpb24YBiABKAsyHC5ZZGIuVG9waWMuUGFydGl0aW9uTG9jYXRpb24SLwoJa2V5X3JhbmdlGAcgASgLMhwuWWRiLlRvcGljLlBhcnRpdGlvbktleVJhbmdlGs0BCgpUb3BpY1N0YXRzEhgKEHN0b3JlX3NpemVfYnl0ZXMYASABKAMSNwoTbWluX2xhc3Rfd3JpdGVfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASNQoSbWF4X3dyaXRlX3RpbWVfbGFnGAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjUKDWJ5dGVzX3dyaXR0ZW4YBCABKAsyHi5ZZGIuVG9waWMuTXVsdGlwbGVXaW5kb3dzU3RhdEoECAYQByKqAQoYRGVzY3JpYmVQYXJ0aXRpb25SZXF1ZXN0EjkKEG9wZXJhdGlvbl9wYXJhbXMYASABKAsyHy5ZZGIuT3BlcmF0aW9ucy5PcGVyYXRpb25QYXJhbXMSDAoEcGF0aBgCIAEoCRIUCgxwYXJ0aXRpb25faWQYAyABKAMSFQoNaW5jbHVkZV9zdGF0cxgEIAEoCBIYChBpbmNsdWRlX2xvY2F0aW9uGAUgASgIIkkKGURlc2NyaWJlUGFydGl0aW9uUmVzcG9uc2USLAoJb3BlcmF0aW9uGAEgASgLMhkuWWRiLk9wZXJhdGlvbnMuT3BlcmF0aW9uIloKF0Rlc2NyaWJlUGFydGl0aW9uUmVzdWx0Ej8KCXBhcnRpdGlvbhgBIAEoCzIsLllkYi5Ub3BpYy5EZXNjcmliZVRvcGljUmVzdWx0LlBhcnRpdGlvbkluZm8ipQEKF0Rlc2NyaWJlQ29uc3VtZXJSZXF1ZXN0EjkKEG9wZXJhdGlvbl9wYXJhbXMYASABKAsyHy5ZZGIuT3BlcmF0aW9ucy5PcGVyYXRpb25QYXJhbXMSDAoEcGF0aBgCIAEoCRIQCghjb25zdW1lchgDIAEoCRIVCg1pbmNsdWRlX3N0YXRzGAQgASgIEhgKEGluY2x1ZGVfbG9jYXRpb24YBSABKAgiSAoYRGVzY3JpYmVDb25zdW1lclJlc3BvbnNlEiwKCW9wZXJhdGlvbhgBIAEoCzIZLllkYi5PcGVyYXRpb25zLk9wZXJhdGlvbiKYBwoWRGVzY3JpYmVDb25zdW1lclJlc3VsdBIfCgRzZWxmGAEgASgLMhEuWWRiLlNjaGVtZS5FbnRyeRIlCghjb25zdW1lchgCIAEoCzITLllkYi5Ub3BpYy5Db25zdW1lchJDCgpwYXJ0aXRpb25zGAMgAygLMi8uWWRiLlRvcGljLkRlc2NyaWJlQ29uc3VtZXJSZXN1bHQuUGFydGl0aW9uSW5mbxq6AgoNUGFydGl0aW9uSW5mbxIUCgxwYXJ0aXRpb25faWQYASABKAMSDgoGYWN0aXZlGAIgASgIEhsKE2NoaWxkX3BhcnRpdGlvbl9pZHMYAyADKAMSHAoUcGFyZW50X3BhcnRpdGlvbl9pZHMYBCADKAMSMgoPcGFydGl0aW9uX3N0YXRzGAUgASgLMhkuWWRiLlRvcGljLlBhcnRpdGlvblN0YXRzEloKGHBhcnRpdGlvbl9jb25zdW1lcl9zdGF0cxgGIAEoCzI4LllkYi5Ub3BpYy5EZXNjcmliZUNvbnN1bWVyUmVzdWx0LlBhcnRpdGlvbkNvbnN1bWVyU3RhdHMSOAoScGFydGl0aW9uX2xvY2F0aW9uGAcgASgLMhwuWWRiLlRvcGljLlBhcnRpdGlvbkxvY2F0aW9uGrMDChZQYXJ0aXRpb25Db25zdW1lclN0YXRzEhgKEGxhc3RfcmVhZF9vZmZzZXQYASABKAMSGAoQY29tbWl0dGVkX29mZnNldBgCIAEoAxIXCg9yZWFkX3Nlc3Npb25faWQYAyABKAkSRgoicGFydGl0aW9uX3JlYWRfc2Vzc2lvbl9jcmVhdGVfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMgoObGFzdF9yZWFkX3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjQKEW1heF9yZWFkX3RpbWVfbGFnGAYgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjUKEm1heF93cml0ZV90aW1lX2xhZxgHIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIyCgpieXRlc19yZWFkGAggASgLMh4uWWRiLlRvcGljLk11bHRpcGxlV2luZG93c1N0YXQSEwoLcmVhZGVyX25hbWUYCyABKAkSGgoSY29ubmVjdGlvbl9ub2RlX2lkGAwgASgFIqACCg5QYXJ0aXRpb25TdGF0cxIyChFwYXJ0aXRpb25fb2Zmc2V0cxgBIAEoCzIXLllkYi5Ub3BpYy5PZmZzZXRzUmFuZ2USGAoQc3RvcmVfc2l6ZV9ieXRlcxgCIAEoAxIzCg9sYXN0X3dyaXRlX3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjUKEm1heF93cml0ZV90aW1lX2xhZxgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI1Cg1ieXRlc193cml0dGVuGAUgASgLMh4uWWRiLlRvcGljLk11bHRpcGxlV2luZG93c1N0YXQSHQoRcGFydGl0aW9uX25vZGVfaWQYCCABKAVCAhgBIocHChFBbHRlclRvcGljUmVxdWVzdBI5ChBvcGVyYXRpb25fcGFyYW1zGAEgASgLMh8uWWRiLk9wZXJhdGlvbnMuT3BlcmF0aW9uUGFyYW1zEgwKBHBhdGgYAiABKAkSSQobYWx0ZXJfcGFydGl0aW9uaW5nX3NldHRpbmdzGAMgASgLMiQuWWRiLlRvcGljLkFsdGVyUGFydGl0aW9uaW5nU2V0dGluZ3MSNwoUc2V0X3JldGVudGlvbl9wZXJpb2QYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SLwoYc2V0X3JldGVudGlvbl9zdG9yYWdlX21iGAUgASgDQgiy5ioEPj0gMEgAiAEBEjgKFHNldF9zdXBwb3J0ZWRfY29kZWNzGAcgASgLMhouWWRiLlRvcGljLlN1cHBvcnRlZENvZGVjcxJBCipzZXRfcGFydGl0aW9uX3dyaXRlX3NwZWVkX2J5dGVzX3Blcl9zZWNvbmQYCCABKANCCLLmKgQ+PSAwSAGIAQESNgofc2V0X3BhcnRpdGlvbl93cml0ZV9idXJzdF9ieXRlcxgJIAEoA0IIsuYqBD49IDBIAogBARJLChBhbHRlcl9hdHRyaWJ1dGVzGAogAygLMjEuWWRiLlRvcGljLkFsdGVyVG9waWNSZXF1ZXN0LkFsdGVyQXR0cmlidXRlc0VudHJ5EjMKDWFkZF9jb25zdW1lcnMYCyADKAsyEy5ZZGIuVG9waWMuQ29uc3VtZXJCB5rmKgMYuBcSHwoOZHJvcF9jb25zdW1lcnMYDCADKAlCB5rmKgMYuBcSOgoPYWx0ZXJfY29uc3VtZXJzGA0gAygLMhguWWRiLlRvcGljLkFsdGVyQ29uc3VtZXJCB5rmKgMYuBcSMgoRc2V0X21ldGVyaW5nX21vZGUYDiABKA4yFy5ZZGIuVG9waWMuTWV0ZXJpbmdNb2RlGjYKFEFsdGVyQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAFCGwoZX3NldF9yZXRlbnRpb25fc3RvcmFnZV9tYkItCitfc2V0X3BhcnRpdGlvbl93cml0ZV9zcGVlZF9ieXRlc19wZXJfc2Vjb25kQiIKIF9zZXRfcGFydGl0aW9uX3dyaXRlX2J1cnN0X2J5dGVzSgQIBhAHIkIKEkFsdGVyVG9waWNSZXNwb25zZRIsCglvcGVyYXRpb24YASABKAsyGS5ZZGIuT3BlcmF0aW9ucy5PcGVyYXRpb24iEgoQQWx0ZXJUb3BpY1Jlc3VsdCJbChBEcm9wVG9waWNSZXF1ZXN0EjkKEG9wZXJhdGlvbl9wYXJhbXMYASABKAsyHy5ZZGIuT3BlcmF0aW9ucy5PcGVyYXRpb25QYXJhbXMSDAoEcGF0aBgCIAEoCSJBChFEcm9wVG9waWNSZXNwb25zZRIsCglvcGVyYXRpb24YASABKAsyGS5ZZGIuT3BlcmF0aW9ucy5PcGVyYXRpb24iEQoPRHJvcFRvcGljUmVzdWx0KoMBCgVDb2RlYxIVChFDT0RFQ19VTlNQRUNJRklFRBAAEg0KCUNPREVDX1JBVxABEg4KCkNPREVDX0daSVAQAhIOCgpDT0RFQ19MWk9QEAMSDgoKQ09ERUNfWlNURBAEEhEKDENPREVDX0NVU1RPTRCQTiIFCAUQj04iCgignAEQ/////wcq8QEKGEF1dG9QYXJ0aXRpb25pbmdTdHJhdGVneRIqCiZBVVRPX1BBUlRJVElPTklOR19TVFJBVEVHWV9VTlNQRUNJRklFRBAAEicKI0FVVE9fUEFSVElUSU9OSU5HX1NUUkFURUdZX0RJU0FCTEVEEAESJwojQVVUT19QQVJUSVRJT05JTkdfU1RSQVRFR1lfU0NBTEVfVVAQAhIwCixBVVRPX1BBUlRJVElPTklOR19TVFJBVEVHWV9TQ0FMRV9VUF9BTkRfRE9XThADEiUKIUFVVE9fUEFSVElUSU9OSU5HX1NUUkFURUdZX1BBVVNFRBAEKnMKDE1ldGVyaW5nTW9kZRIdChlNRVRFUklOR19NT0RFX1VOU1BFQ0lGSUVEEAASIwofTUVURVJJTkdfTU9ERV9SRVNFUlZFRF9DQVBBQ0lUWRABEh8KG01FVEVSSU5HX01PREVfUkVRVUVTVF9VTklUUxACQlMKFHRlY2gueWRiLnByb3RvLnRvcGljWjhnaXRodWIuY29tL3lkYi1wbGF0Zm9ybS95ZGItZ28tZ2VucHJvdG8vcHJvdG9zL1lkYl9Ub3BpY/gBAWIGcHJvdG8z", [file_protos_ydb_operation, file_protos_ydb_scheme, file_protos_ydb_status_codes, file_protos_ydb_issue_message, file_protos_annotations_sensitive, file_protos_annotations_validation, file_google_protobuf_duration, file_google_protobuf_timestamp]);

/**
 * Description of supported codecs.
 *
 * @generated from message Ydb.Topic.SupportedCodecs
 */
export type SupportedCodecs = Message<"Ydb.Topic.SupportedCodecs"> & {
  /**
   * List of supported codecs.
   * See enum Codec above for values.
   *
   * @generated from field: repeated int32 codecs = 1;
   */
  codecs: number[];
};

/**
 * Describes the message Ydb.Topic.SupportedCodecs.
 * Use `create(SupportedCodecsSchema)` to create a new message.
 */
export const SupportedCodecsSchema: GenMessage<SupportedCodecs> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 0);

/**
 * Represents range [start, end).
 * I.e. (end - 1) is the greatest of offsets, included in non-empty range.
 *
 * @generated from message Ydb.Topic.OffsetsRange
 */
export type OffsetsRange = Message<"Ydb.Topic.OffsetsRange"> & {
  /**
   * @generated from field: int64 start = 1;
   */
  start: bigint;

  /**
   * @generated from field: int64 end = 2;
   */
  end: bigint;
};

/**
 * Describes the message Ydb.Topic.OffsetsRange.
 * Use `create(OffsetsRangeSchema)` to create a new message.
 */
export const OffsetsRangeSchema: GenMessage<OffsetsRange> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 1);

/**
 * In-session reauthentication and reauthorization, lets user increase session lifetime.
 * Client should wait for UpdateTokenResponse before sending next UpdateTokenRequest.
 *
 * @generated from message Ydb.Topic.UpdateTokenRequest
 */
export type UpdateTokenRequest = Message<"Ydb.Topic.UpdateTokenRequest"> & {
  /**
   * @generated from field: string token = 1;
   */
  token: string;
};

/**
 * Describes the message Ydb.Topic.UpdateTokenRequest.
 * Use `create(UpdateTokenRequestSchema)` to create a new message.
 */
export const UpdateTokenRequestSchema: GenMessage<UpdateTokenRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 2);

/**
 * @generated from message Ydb.Topic.UpdateTokenResponse
 */
export type UpdateTokenResponse = Message<"Ydb.Topic.UpdateTokenResponse"> & {
};

/**
 * Describes the message Ydb.Topic.UpdateTokenResponse.
 * Use `create(UpdateTokenResponseSchema)` to create a new message.
 */
export const UpdateTokenResponseSchema: GenMessage<UpdateTokenResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 3);

/**
 * @generated from message Ydb.Topic.PartitionWithGeneration
 */
export type PartitionWithGeneration = Message<"Ydb.Topic.PartitionWithGeneration"> & {
  /**
   * Partition identifier.
   *
   * @generated from field: int64 partition_id = 1;
   */
  partitionId: bigint;

  /**
   * Partition generation.
   *
   * @generated from field: int64 generation = 2;
   */
  generation: bigint;
};

/**
 * Describes the message Ydb.Topic.PartitionWithGeneration.
 * Use `create(PartitionWithGenerationSchema)` to create a new message.
 */
export const PartitionWithGenerationSchema: GenMessage<PartitionWithGeneration> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 4);

/**
 * @generated from message Ydb.Topic.MetadataItem
 */
export type MetadataItem = Message<"Ydb.Topic.MetadataItem"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;
};

/**
 * Describes the message Ydb.Topic.MetadataItem.
 * Use `create(MetadataItemSchema)` to create a new message.
 */
export const MetadataItemSchema: GenMessage<MetadataItem> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 5);

/**
 * Messages for bidirectional streaming rpc StreamWrite
 *
 * @generated from message Ydb.Topic.StreamWriteMessage
 */
export type StreamWriteMessage = Message<"Ydb.Topic.StreamWriteMessage"> & {
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.
 * Use `create(StreamWriteMessageSchema)` to create a new message.
 */
export const StreamWriteMessageSchema: GenMessage<StreamWriteMessage> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6);

/**
 * Client-server message for write session. Contains one of:
 *     InitRequest - handshake request.
 *     WriteRequest - portion of data to be written.
 *     UpdateTokenRequest - user credentials if update is needed.
 *
 * @generated from message Ydb.Topic.StreamWriteMessage.FromClient
 */
export type StreamWriteMessage_FromClient = Message<"Ydb.Topic.StreamWriteMessage.FromClient"> & {
  /**
   * @generated from oneof Ydb.Topic.StreamWriteMessage.FromClient.client_message
   */
  clientMessage: {
    /**
     * @generated from field: Ydb.Topic.StreamWriteMessage.InitRequest init_request = 1;
     */
    value: StreamWriteMessage_InitRequest;
    case: "initRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamWriteMessage.WriteRequest write_request = 2;
     */
    value: StreamWriteMessage_WriteRequest;
    case: "writeRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.UpdateTokenRequest update_token_request = 3;
     */
    value: UpdateTokenRequest;
    case: "updateTokenRequest";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.FromClient.
 * Use `create(StreamWriteMessage_FromClientSchema)` to create a new message.
 */
export const StreamWriteMessage_FromClientSchema: GenMessage<StreamWriteMessage_FromClient> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 0);

/**
 * Server-client message for write session. Contains either non-success status, or one of:
 *     InitResponse - correct handshake response.
 *     WriteResponse - acknowledgment of storing client messages.
 *     UpdateTokenResponse - acknowledgment of reauthentication and reauthorization.
 *
 * @generated from message Ydb.Topic.StreamWriteMessage.FromServer
 */
export type StreamWriteMessage_FromServer = Message<"Ydb.Topic.StreamWriteMessage.FromServer"> & {
  /**
   * Server status of response.
   *
   * @generated from field: Ydb.StatusIds.StatusCode status = 1;
   */
  status: StatusIds_StatusCode;

  /**
   * Issues if any.
   *
   * @generated from field: repeated Ydb.Issue.IssueMessage issues = 2;
   */
  issues: IssueMessage[];

  /**
   * @generated from oneof Ydb.Topic.StreamWriteMessage.FromServer.server_message
   */
  serverMessage: {
    /**
     * @generated from field: Ydb.Topic.StreamWriteMessage.InitResponse init_response = 3;
     */
    value: StreamWriteMessage_InitResponse;
    case: "initResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamWriteMessage.WriteResponse write_response = 4;
     */
    value: StreamWriteMessage_WriteResponse;
    case: "writeResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.UpdateTokenResponse update_token_response = 5;
     */
    value: UpdateTokenResponse;
    case: "updateTokenResponse";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.FromServer.
 * Use `create(StreamWriteMessage_FromServerSchema)` to create a new message.
 */
export const StreamWriteMessage_FromServerSchema: GenMessage<StreamWriteMessage_FromServer> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 1);

/**
 * Handshake request that must be sent to server first.
 *
 * @generated from message Ydb.Topic.StreamWriteMessage.InitRequest
 */
export type StreamWriteMessage_InitRequest = Message<"Ydb.Topic.StreamWriteMessage.InitRequest"> & {
  /**
   * Full path of topic to write to.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Producer identifier of client data stream.
   * Used for message deduplication by sequence numbers.
   *
   * @generated from field: string producer_id = 2;
   */
  producerId: string;

  /**
   * User metadata attached to this write session.
   * Reader will get this session meta data with each message read.
   *
   * @generated from field: map<string, string> write_session_meta = 3;
   */
  writeSessionMeta: { [key: string]: string };

  /**
   * Option for setting order on messages.
   * If neither is set, no guarantees on ordering or partitions to write to.
   *
   * @generated from oneof Ydb.Topic.StreamWriteMessage.InitRequest.partitioning
   */
  partitioning: {
    /**
     * All messages with given pair (producer_id, message_group_id) go to single partition in order of writes.
     *
     * @generated from field: string message_group_id = 4;
     */
    value: string;
    case: "messageGroupId";
  } | {
    /**
     * Explicit partition id to write to.
     *
     * @generated from field: int64 partition_id = 5;
     */
    value: bigint;
    case: "partitionId";
  } | {
    /**
     * Explicit partition location to write to.
     *
     * @generated from field: Ydb.Topic.PartitionWithGeneration partition_with_generation = 7;
     */
    value: PartitionWithGeneration;
    case: "partitionWithGeneration";
  } | { case: undefined; value?: undefined };

  /**
   * Explicitly request for last sequential number
   * It may be expensive, if producer wrote to many partitions before.
   *
   * @generated from field: bool get_last_seq_no = 6;
   */
  getLastSeqNo: boolean;
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.InitRequest.
 * Use `create(StreamWriteMessage_InitRequestSchema)` to create a new message.
 */
export const StreamWriteMessage_InitRequestSchema: GenMessage<StreamWriteMessage_InitRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 2);

/**
 * Response to the handshake.
 *
 * @generated from message Ydb.Topic.StreamWriteMessage.InitResponse
 */
export type StreamWriteMessage_InitResponse = Message<"Ydb.Topic.StreamWriteMessage.InitResponse"> & {
  /**
   * Last persisted message's sequence number for this producer.
   * Zero for new producer.
   *
   * @generated from field: int64 last_seq_no = 1;
   */
  lastSeqNo: bigint;

  /**
   * Unique identifier of write session. Used for debug purposes.
   *
   * @generated from field: string session_id = 2;
   */
  sessionId: string;

  /**
   * Identifier of partition that is matched for this write session.
   *
   * @generated from field: int64 partition_id = 3;
   */
  partitionId: bigint;

  /**
   * Client can only use compression codecs from this set to write messages to topic.
   * Otherwise session will be closed with BAD_REQUEST.
   *
   * @generated from field: Ydb.Topic.SupportedCodecs supported_codecs = 4;
   */
  supportedCodecs?: SupportedCodecs;
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.InitResponse.
 * Use `create(StreamWriteMessage_InitResponseSchema)` to create a new message.
 */
export const StreamWriteMessage_InitResponseSchema: GenMessage<StreamWriteMessage_InitResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 3);

/**
 * Represents portion of client messages.
 *
 * @generated from message Ydb.Topic.StreamWriteMessage.WriteRequest
 */
export type StreamWriteMessage_WriteRequest = Message<"Ydb.Topic.StreamWriteMessage.WriteRequest"> & {
  /**
   * @generated from field: repeated Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData messages = 1;
   */
  messages: StreamWriteMessage_WriteRequest_MessageData[];

  /**
   * Codec that is used for data compression.
   * See enum Codec above for values.
   *
   * @generated from field: int32 codec = 2;
   */
  codec: number;

  /**
   * @generated from field: optional Ydb.Topic.TransactionIdentity tx = 3;
   */
  tx?: TransactionIdentity;
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.WriteRequest.
 * Use `create(StreamWriteMessage_WriteRequestSchema)` to create a new message.
 */
export const StreamWriteMessage_WriteRequestSchema: GenMessage<StreamWriteMessage_WriteRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 4);

/**
 * @generated from message Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData
 */
export type StreamWriteMessage_WriteRequest_MessageData = Message<"Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData"> & {
  /**
   * Message sequence number, provided by client for deduplication.
   * Starts at 1
   *
   * @generated from field: int64 seq_no = 1;
   */
  seqNo: bigint;

  /**
   * Creation timestamp
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Compressed client message body.
   *
   * @generated from field: bytes data = 3;
   */
  data: Uint8Array;

  /**
   * Uncompressed size of client message body.
   *
   * @generated from field: int64 uncompressed_size = 4;
   */
  uncompressedSize: bigint;

  /**
   * Per-message override for respective write session settings.
   *
   * @generated from oneof Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData.partitioning
   */
  partitioning: {
    /**
     * All messages with given pair (producer_id, message_group_id) go to single partition in order of writes.
     *
     * @generated from field: string message_group_id = 5;
     */
    value: string;
    case: "messageGroupId";
  } | {
    /**
     * Explicit partition id to write to.
     *
     * @generated from field: int64 partition_id = 6;
     */
    value: bigint;
    case: "partitionId";
  } | {
    /**
     * Explicit partition location to write to.
     *
     * @generated from field: Ydb.Topic.PartitionWithGeneration partition_with_generation = 8;
     */
    value: PartitionWithGeneration;
    case: "partitionWithGeneration";
  } | { case: undefined; value?: undefined };

  /**
   * Message metadata. Overall size is limited to 4096 symbols (all keys and values combined).
   *
   * @generated from field: repeated Ydb.Topic.MetadataItem metadata_items = 7;
   */
  metadataItems: MetadataItem[];
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData.
 * Use `create(StreamWriteMessage_WriteRequest_MessageDataSchema)` to create a new message.
 */
export const StreamWriteMessage_WriteRequest_MessageDataSchema: GenMessage<StreamWriteMessage_WriteRequest_MessageData> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 4, 0);

/**
 * Message that represents acknowledgment for sequence of client messages.
 * This sequence is persisted together so write statistics is for messages batch.
 *
 * @generated from message Ydb.Topic.StreamWriteMessage.WriteResponse
 */
export type StreamWriteMessage_WriteResponse = Message<"Ydb.Topic.StreamWriteMessage.WriteResponse"> & {
  /**
   * Number of acks is equal to number of messages in the corresponding WriteRequests.
   *
   * @generated from field: repeated Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck acks = 1;
   */
  acks: StreamWriteMessage_WriteResponse_WriteAck[];

  /**
   * Assigned partition for all client messages inside this batch.
   * This actual partition may differ from that returned in InitResponse
   * or other WriteResponses in this write session.
   *
   * @generated from field: int64 partition_id = 2;
   */
  partitionId: bigint;

  /**
   * Write statistics for this sequence of client messages.
   *
   * @generated from field: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics write_statistics = 3;
   */
  writeStatistics?: StreamWriteMessage_WriteResponse_WriteStatistics;
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.WriteResponse.
 * Use `create(StreamWriteMessage_WriteResponseSchema)` to create a new message.
 */
export const StreamWriteMessage_WriteResponseSchema: GenMessage<StreamWriteMessage_WriteResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 5);

/**
 * Acknowledgment for one persistently written message.
 *
 * @generated from message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck
 */
export type StreamWriteMessage_WriteResponse_WriteAck = Message<"Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck"> & {
  /**
   * Sequence number as in WriteRequest.
   *
   * @generated from field: int64 seq_no = 1;
   */
  seqNo: bigint;

  /**
   * Either message is written for the first time or duplicate.
   *
   * @generated from oneof Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.message_write_status
   */
  messageWriteStatus: {
    /**
     * @generated from field: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Written written = 2;
     */
    value: StreamWriteMessage_WriteResponse_WriteAck_Written;
    case: "written";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped skipped = 3;
     */
    value: StreamWriteMessage_WriteResponse_WriteAck_Skipped;
    case: "skipped";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTx written_in_tx = 4;
     */
    value: StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx;
    case: "writtenInTx";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.
 * Use `create(StreamWriteMessage_WriteResponse_WriteAckSchema)` to create a new message.
 */
export const StreamWriteMessage_WriteResponse_WriteAckSchema: GenMessage<StreamWriteMessage_WriteResponse_WriteAck> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 5, 0);

/**
 * @generated from message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Written
 */
export type StreamWriteMessage_WriteResponse_WriteAck_Written = Message<"Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Written"> & {
  /**
   * Assigned partition offset.
   *
   * @generated from field: int64 offset = 1;
   */
  offset: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Written.
 * Use `create(StreamWriteMessage_WriteResponse_WriteAck_WrittenSchema)` to create a new message.
 */
export const StreamWriteMessage_WriteResponse_WriteAck_WrittenSchema: GenMessage<StreamWriteMessage_WriteResponse_WriteAck_Written> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 5, 0, 0);

/**
 * @generated from message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped
 */
export type StreamWriteMessage_WriteResponse_WriteAck_Skipped = Message<"Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped"> & {
  /**
   * @generated from field: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.Reason reason = 1;
   */
  reason: StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason;
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.
 * Use `create(StreamWriteMessage_WriteResponse_WriteAck_SkippedSchema)` to create a new message.
 */
export const StreamWriteMessage_WriteResponse_WriteAck_SkippedSchema: GenMessage<StreamWriteMessage_WriteResponse_WriteAck_Skipped> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 5, 0, 1);

/**
 * @generated from enum Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.Reason
 */
export enum StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason {
  /**
   * @generated from enum value: REASON_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REASON_ALREADY_WRITTEN = 1;
   */
  ALREADY_WRITTEN = 1,
}

/**
 * Describes the enum Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.Reason.
 */
export const StreamWriteMessage_WriteResponse_WriteAck_Skipped_ReasonSchema: GenEnum<StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason> = /*@__PURE__*/
  enumDesc(file_protos_ydb_topic, 6, 5, 0, 1, 0);

/**
 * @generated from message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTx
 */
export type StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx = Message<"Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTx"> & {
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTx.
 * Use `create(StreamWriteMessage_WriteResponse_WriteAck_WrittenInTxSchema)` to create a new message.
 */
export const StreamWriteMessage_WriteResponse_WriteAck_WrittenInTxSchema: GenMessage<StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 5, 0, 2);

/**
 * Message with write statistics.
 *
 * @generated from message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics
 */
export type StreamWriteMessage_WriteResponse_WriteStatistics = Message<"Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics"> & {
  /**
   * Time spent in persisting of data. Same for each message in response.
   *
   * @generated from field: google.protobuf.Duration persisting_time = 1;
   */
  persistingTime?: Duration;

  /**
   * Time spent in queue before persisting, minimal of all messages in response.
   *
   * @generated from field: google.protobuf.Duration min_queue_wait_time = 2;
   */
  minQueueWaitTime?: Duration;

  /**
   * Time spent in queue before persisting, maximal of all messages in response.
   *
   * @generated from field: google.protobuf.Duration max_queue_wait_time = 3;
   */
  maxQueueWaitTime?: Duration;

  /**
   * Time spent awaiting for partition write quota. Same for each message in response.
   *
   * @generated from field: google.protobuf.Duration partition_quota_wait_time = 4;
   */
  partitionQuotaWaitTime?: Duration;

  /**
   * Time spent awaiting for topic write quota. Same for each message in response.
   *
   * @generated from field: google.protobuf.Duration topic_quota_wait_time = 5;
   */
  topicQuotaWaitTime?: Duration;
};

/**
 * Describes the message Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.
 * Use `create(StreamWriteMessage_WriteResponse_WriteStatisticsSchema)` to create a new message.
 */
export const StreamWriteMessage_WriteResponse_WriteStatisticsSchema: GenMessage<StreamWriteMessage_WriteResponse_WriteStatistics> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 6, 5, 1);

/**
 * Messages for bidirectional streaming rpc StreamRead
 *
 * @generated from message Ydb.Topic.StreamReadMessage
 */
export type StreamReadMessage = Message<"Ydb.Topic.StreamReadMessage"> & {
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.
 * Use `create(StreamReadMessageSchema)` to create a new message.
 */
export const StreamReadMessageSchema: GenMessage<StreamReadMessage> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7);

/**
 * Within a StreamRead session delivered messages are separated by partition.
 * Reads from a single partition are represented by a partition session.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.PartitionSession
 */
export type StreamReadMessage_PartitionSession = Message<"Ydb.Topic.StreamReadMessage.PartitionSession"> & {
  /**
   * Identifier of partition session. Unique inside one RPC call.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Topic path of partition.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Partition identifier.
   *
   * @generated from field: int64 partition_id = 3;
   */
  partitionId: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.PartitionSession.
 * Use `create(StreamReadMessage_PartitionSessionSchema)` to create a new message.
 */
export const StreamReadMessage_PartitionSessionSchema: GenMessage<StreamReadMessage_PartitionSession> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 0);

/**
 * Client-server message for read session. Contains one of:
 *     InitRequest - handshake request.
 *     ReadRequest - request for data.
 *     CommitOffsetRequest - request for commit of some read data.
 *     PartitionSessionStatusRequest - request for session status
 *     UpdateTokenRequest - request to update auth token
 *     DirectReadAck - client signals it has finished direct reading from the partition node.
 *
 *     StartPartitionSessionResponse - Response to StreamReadServerMessage.StartPartitionSessionRequest.
 *         Client signals it is ready to get data from partition.
 *     StopPartitionSessionResponse - Response to StreamReadServerMessage.StopPartitionSessionRequest.
 *         Client signals it has finished working with partition. Mandatory for graceful stop, optional otherwise.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.FromClient
 */
export type StreamReadMessage_FromClient = Message<"Ydb.Topic.StreamReadMessage.FromClient"> & {
  /**
   * @generated from oneof Ydb.Topic.StreamReadMessage.FromClient.client_message
   */
  clientMessage: {
    /**
     * Client requests.
     *
     * @generated from field: Ydb.Topic.StreamReadMessage.InitRequest init_request = 1;
     */
    value: StreamReadMessage_InitRequest;
    case: "initRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.ReadRequest read_request = 2;
     */
    value: StreamReadMessage_ReadRequest;
    case: "readRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.CommitOffsetRequest commit_offset_request = 3;
     */
    value: StreamReadMessage_CommitOffsetRequest;
    case: "commitOffsetRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequest partition_session_status_request = 4;
     */
    value: StreamReadMessage_PartitionSessionStatusRequest;
    case: "partitionSessionStatusRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.UpdateTokenRequest update_token_request = 5;
     */
    value: UpdateTokenRequest;
    case: "updateTokenRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.DirectReadAck direct_read_ack = 8;
     */
    value: StreamReadMessage_DirectReadAck;
    case: "directReadAck";
  } | {
    /**
     * Responses to respective server commands.
     *
     * @generated from field: Ydb.Topic.StreamReadMessage.StartPartitionSessionResponse start_partition_session_response = 6;
     */
    value: StreamReadMessage_StartPartitionSessionResponse;
    case: "startPartitionSessionResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.StopPartitionSessionResponse stop_partition_session_response = 7;
     */
    value: StreamReadMessage_StopPartitionSessionResponse;
    case: "stopPartitionSessionResponse";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.FromClient.
 * Use `create(StreamReadMessage_FromClientSchema)` to create a new message.
 */
export const StreamReadMessage_FromClientSchema: GenMessage<StreamReadMessage_FromClient> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 1);

/**
 * Server-client message for read session. Contains one of:
 *     InitResponse - handshake response from server.
 *     ReadResponse - portion of data.
 *     CommitOffsetResponse - acknowledgment for commit.
 *     PartitionSessionStatusResponse - server response with partition session status.
 *     UpdateTokenResponse - acknowledgment of token update.
 *
 *     StartPartitionSessionRequest - command from server to create a partition session.
 *     StopPartitionSessionRequest - command from server to destroy a partition session.
 *     UpdatePartitionSession - command from server to update a partition session.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.FromServer
 */
export type StreamReadMessage_FromServer = Message<"Ydb.Topic.StreamReadMessage.FromServer"> & {
  /**
   * Server status of response.
   *
   * @generated from field: Ydb.StatusIds.StatusCode status = 1;
   */
  status: StatusIds_StatusCode;

  /**
   * Issues if any.
   *
   * @generated from field: repeated Ydb.Issue.IssueMessage issues = 2;
   */
  issues: IssueMessage[];

  /**
   * @generated from oneof Ydb.Topic.StreamReadMessage.FromServer.server_message
   */
  serverMessage: {
    /**
     * Responses to respective client requests.
     *
     * @generated from field: Ydb.Topic.StreamReadMessage.InitResponse init_response = 3;
     */
    value: StreamReadMessage_InitResponse;
    case: "initResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.ReadResponse read_response = 4;
     */
    value: StreamReadMessage_ReadResponse;
    case: "readResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.CommitOffsetResponse commit_offset_response = 5;
     */
    value: StreamReadMessage_CommitOffsetResponse;
    case: "commitOffsetResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse partition_session_status_response = 6;
     */
    value: StreamReadMessage_PartitionSessionStatusResponse;
    case: "partitionSessionStatusResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.UpdateTokenResponse update_token_response = 7;
     */
    value: UpdateTokenResponse;
    case: "updateTokenResponse";
  } | {
    /**
     * Server commands.
     *
     * @generated from field: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest start_partition_session_request = 8;
     */
    value: StreamReadMessage_StartPartitionSessionRequest;
    case: "startPartitionSessionRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.StopPartitionSessionRequest stop_partition_session_request = 9;
     */
    value: StreamReadMessage_StopPartitionSessionRequest;
    case: "stopPartitionSessionRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.UpdatePartitionSession update_partition_session = 10;
     */
    value: StreamReadMessage_UpdatePartitionSession;
    case: "updatePartitionSession";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamReadMessage.EndPartitionSession end_partition_session = 11;
     */
    value: StreamReadMessage_EndPartitionSession;
    case: "endPartitionSession";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.FromServer.
 * Use `create(StreamReadMessage_FromServerSchema)` to create a new message.
 */
export const StreamReadMessage_FromServerSchema: GenMessage<StreamReadMessage_FromServer> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 2);

/**
 * Handshake request.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.InitRequest
 */
export type StreamReadMessage_InitRequest = Message<"Ydb.Topic.StreamReadMessage.InitRequest"> & {
  /**
   * Message that describes topic to read.
   * Topics that will be read by this session.
   *
   * @generated from field: repeated Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings topics_read_settings = 1;
   */
  topicsReadSettings: StreamReadMessage_InitRequest_TopicReadSettings[];

  /**
   * Path of consumer that is used for reading by this session.
   *
   * @generated from field: string consumer = 2;
   */
  consumer: string;

  /**
   * Optional name. Will be shown in debug stat.
   *
   * @generated from field: string reader_name = 3;
   */
  readerName: string;

  /**
   * Direct reading from a partition node.
   *
   * @generated from field: bool direct_read = 4;
   */
  directRead: boolean;

  /**
   * Indicates that the SDK supports auto partitioning.
   *
   * @generated from field: bool auto_partitioning_support = 5;
   */
  autoPartitioningSupport: boolean;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.InitRequest.
 * Use `create(StreamReadMessage_InitRequestSchema)` to create a new message.
 */
export const StreamReadMessage_InitRequestSchema: GenMessage<StreamReadMessage_InitRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 3);

/**
 * @generated from message Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings
 */
export type StreamReadMessage_InitRequest_TopicReadSettings = Message<"Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings"> & {
  /**
   * Topic path.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Partitions that will be read by this session.
   * If list is empty - then session will read all partitions.
   *
   * @generated from field: repeated int64 partition_ids = 2;
   */
  partitionIds: bigint[];

  /**
   * Skip all messages that has write timestamp smaller than now - max_lag.
   * Zero means infinite lag.
   *
   * @generated from field: google.protobuf.Duration max_lag = 3;
   */
  maxLag?: Duration;

  /**
   * Read data only after this timestamp from this topic.
   * Read only messages with 'written_at' value greater or equal than this timestamp.
   *
   * @generated from field: google.protobuf.Timestamp read_from = 4;
   */
  readFrom?: Timestamp;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings.
 * Use `create(StreamReadMessage_InitRequest_TopicReadSettingsSchema)` to create a new message.
 */
export const StreamReadMessage_InitRequest_TopicReadSettingsSchema: GenMessage<StreamReadMessage_InitRequest_TopicReadSettings> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 3, 0);

/**
 * Handshake response.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.InitResponse
 */
export type StreamReadMessage_InitResponse = Message<"Ydb.Topic.StreamReadMessage.InitResponse"> & {
  /**
   * Read session identifier.
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.InitResponse.
 * Use `create(StreamReadMessage_InitResponseSchema)` to create a new message.
 */
export const StreamReadMessage_InitResponseSchema: GenMessage<StreamReadMessage_InitResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 4);

/**
 * Message that represents client readiness for receiving more data.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.ReadRequest
 */
export type StreamReadMessage_ReadRequest = Message<"Ydb.Topic.StreamReadMessage.ReadRequest"> & {
  /**
   * Server and client each keep track of total bytes size of all ReadResponses.
   * When client is ready to receive N more bytes in responses (to increment possible total by N),
   * it sends a ReadRequest with bytes_size = N.
   * bytes_size value must be positive.
   * So in expression 'A = (sum of bytes_size in all ReadRequests) - (sum of bytes_size in all ReadResponses)'
   *   server will keep A (available size for responses) non-negative.
   * But there is an exception. If server receives ReadRequest, and the first message in response exceeds A -
   * then it will still be delivered, and A will become negative until enough additional ReadRequests.
   *
   * Example:
   * 1) Let client have 200 bytes buffer. It sends ReadRequest with bytes_size = 200;
   * 2) Server may return one ReadResponse with bytes_size = 70 and than another 80 bytes response;
   *    now client buffer has 50 free bytes, server is free to send up to 50 bytes in responses.
   * 3) Client processes 100 bytes from buffer, now buffer free space is 150 bytes,
   *    so client sends ReadRequest with bytes_size = 100;
   * 4) Server is free to send up to 50 + 100 = 150 bytes. But the next read message is too big,
   *    and it sends 160 bytes ReadResponse.
   * 5) Let's assume client somehow processes it, and its 200 bytes buffer is free again.
   *    It should account for excess 10 bytes and send ReadRequest with bytes_size = 210.
   *
   * @generated from field: int64 bytes_size = 1;
   */
  bytesSize: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.ReadRequest.
 * Use `create(StreamReadMessage_ReadRequestSchema)` to create a new message.
 */
export const StreamReadMessage_ReadRequestSchema: GenMessage<StreamReadMessage_ReadRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 5);

/**
 * Data read.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.ReadResponse
 */
export type StreamReadMessage_ReadResponse = Message<"Ydb.Topic.StreamReadMessage.ReadResponse"> & {
  /**
   * Client messages, divided by partitions.
   *
   * @generated from field: repeated Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData partition_data = 1;
   */
  partitionData: StreamReadMessage_ReadResponse_PartitionData[];

  /**
   * Total size in bytes of this response as calculated by server.
   * See ReadRequest comment above.
   *
   * @generated from field: int64 bytes_size = 2;
   */
  bytesSize: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.ReadResponse.
 * Use `create(StreamReadMessage_ReadResponseSchema)` to create a new message.
 */
export const StreamReadMessage_ReadResponseSchema: GenMessage<StreamReadMessage_ReadResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 6);

/**
 * One client message representation.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.ReadResponse.MessageData
 */
export type StreamReadMessage_ReadResponse_MessageData = Message<"Ydb.Topic.StreamReadMessage.ReadResponse.MessageData"> & {
  /**
   * Partition offset in partition that assigned for message.
   *
   * unique value for client side deduplication - Topic:Partition:Offset
   *
   * @generated from field: int64 offset = 1;
   */
  offset: bigint;

  /**
   * Sequence number that provided with message on write from client.
   *
   * @generated from field: int64 seq_no = 2;
   */
  seqNo: bigint;

  /**
   * Timestamp of creation of message provided on write from client.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * Compressed client message body.
   *
   * @generated from field: bytes data = 5;
   */
  data: Uint8Array;

  /**
   * Uncompressed size of client message body.
   * sent as is from WriteRequest, without check on server side. May be empty (for writes from old client) or wrong (if bug in writer).
   * Use it for optimization purposes only, don't trust it.
   *
   * @generated from field: int64 uncompressed_size = 6;
   */
  uncompressedSize: bigint;

  /**
   * Filled if message_group_id was set on message write.
   *
   * @generated from field: string message_group_id = 7;
   */
  messageGroupId: string;

  /**
   * @generated from field: repeated Ydb.Topic.MetadataItem metadata_items = 8;
   */
  metadataItems: MetadataItem[];
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.ReadResponse.MessageData.
 * Use `create(StreamReadMessage_ReadResponse_MessageDataSchema)` to create a new message.
 */
export const StreamReadMessage_ReadResponse_MessageDataSchema: GenMessage<StreamReadMessage_ReadResponse_MessageData> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 6, 0);

/**
 * Representation of sequence of client messages from one write session.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.ReadResponse.Batch
 */
export type StreamReadMessage_ReadResponse_Batch = Message<"Ydb.Topic.StreamReadMessage.ReadResponse.Batch"> & {
  /**
   * List of client messages.
   *
   * @generated from field: repeated Ydb.Topic.StreamReadMessage.ReadResponse.MessageData message_data = 1;
   */
  messageData: StreamReadMessage_ReadResponse_MessageData[];

  /**
   * Producer identifier provided by client for this batch of client messages.
   *
   * @generated from field: string producer_id = 2;
   */
  producerId: string;

  /**
   * Client metadata attached to write session, the same for all messages in batch.
   *
   * @generated from field: map<string, string> write_session_meta = 3;
   */
  writeSessionMeta: { [key: string]: string };

  /**
   * Codec that is used for data compression.
   * See enum Codec above for values.
   *
   * @generated from field: int32 codec = 4;
   */
  codec: number;

  /**
   * Persist timestamp on server for batch.
   *
   * @generated from field: google.protobuf.Timestamp written_at = 5;
   */
  writtenAt?: Timestamp;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.ReadResponse.Batch.
 * Use `create(StreamReadMessage_ReadResponse_BatchSchema)` to create a new message.
 */
export const StreamReadMessage_ReadResponse_BatchSchema: GenMessage<StreamReadMessage_ReadResponse_Batch> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 6, 1);

/**
 * Representation of sequence of messages from one partition.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData
 */
export type StreamReadMessage_ReadResponse_PartitionData = Message<"Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData"> & {
  /**
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Client messages, divided by write sessions.
   *
   * @generated from field: repeated Ydb.Topic.StreamReadMessage.ReadResponse.Batch batches = 2;
   */
  batches: StreamReadMessage_ReadResponse_Batch[];
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData.
 * Use `create(StreamReadMessage_ReadResponse_PartitionDataSchema)` to create a new message.
 */
export const StreamReadMessage_ReadResponse_PartitionDataSchema: GenMessage<StreamReadMessage_ReadResponse_PartitionData> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 6, 2);

/**
 * Signal for server that client processed some read data.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.CommitOffsetRequest
 */
export type StreamReadMessage_CommitOffsetRequest = Message<"Ydb.Topic.StreamReadMessage.CommitOffsetRequest"> & {
  /**
   * Partition offsets that indicates processed data.
   *
   * @generated from field: repeated Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset commit_offsets = 1;
   */
  commitOffsets: StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset[];
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.CommitOffsetRequest.
 * Use `create(StreamReadMessage_CommitOffsetRequestSchema)` to create a new message.
 */
export const StreamReadMessage_CommitOffsetRequestSchema: GenMessage<StreamReadMessage_CommitOffsetRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 7);

/**
 * Message that is used for describing commit.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset
 */
export type StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset = Message<"Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset"> & {
  /**
   * Identifier of partition session with data to commit.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Processed offsets ranges, repeated in case of disjoint ranges.
   *
   * @generated from field: repeated Ydb.Topic.OffsetsRange offsets = 2;
   */
  offsets: OffsetsRange[];
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset.
 * Use `create(StreamReadMessage_CommitOffsetRequest_PartitionCommitOffsetSchema)` to create a new message.
 */
export const StreamReadMessage_CommitOffsetRequest_PartitionCommitOffsetSchema: GenMessage<StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 7, 0);

/**
 * Acknowledgement for commits.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.CommitOffsetResponse
 */
export type StreamReadMessage_CommitOffsetResponse = Message<"Ydb.Topic.StreamReadMessage.CommitOffsetResponse"> & {
  /**
   * Partitions with progress.
   *
   * @generated from field: repeated Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffset partitions_committed_offsets = 1;
   */
  partitionsCommittedOffsets: StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset[];
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.CommitOffsetResponse.
 * Use `create(StreamReadMessage_CommitOffsetResponseSchema)` to create a new message.
 */
export const StreamReadMessage_CommitOffsetResponseSchema: GenMessage<StreamReadMessage_CommitOffsetResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 8);

/**
 * Per-partition commit representation.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffset
 */
export type StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset = Message<"Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffset"> & {
  /**
   * Partition session identifier.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Upper bound for committed offsets.
   *
   * @generated from field: int64 committed_offset = 2;
   */
  committedOffset: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffset.
 * Use `create(StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffsetSchema)` to create a new message.
 */
export const StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffsetSchema: GenMessage<StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 8, 0);

/**
 * @generated from message Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequest
 */
export type StreamReadMessage_PartitionSessionStatusRequest = Message<"Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequest"> & {
  /**
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequest.
 * Use `create(StreamReadMessage_PartitionSessionStatusRequestSchema)` to create a new message.
 */
export const StreamReadMessage_PartitionSessionStatusRequestSchema: GenMessage<StreamReadMessage_PartitionSessionStatusRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 9);

/**
 * Response to status request.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse
 */
export type StreamReadMessage_PartitionSessionStatusResponse = Message<"Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse"> & {
  /**
   * Identifier of partition session whose status was requested.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Partition contains messages with offsets in range [start, end).
   *
   * @generated from field: Ydb.Topic.OffsetsRange partition_offsets = 2;
   */
  partitionOffsets?: OffsetsRange;

  /**
   * Each offset up to and including (committed_offset - 1) was fully processed.
   *
   * @generated from field: int64 committed_offset = 3;
   */
  committedOffset: bigint;

  /**
   * Write timestamp of next message written to this partition will be no less than write_time_high_watermark.
   *
   * @generated from field: google.protobuf.Timestamp write_time_high_watermark = 4;
   */
  writeTimeHighWatermark?: Timestamp;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse.
 * Use `create(StreamReadMessage_PartitionSessionStatusResponseSchema)` to create a new message.
 */
export const StreamReadMessage_PartitionSessionStatusResponseSchema: GenMessage<StreamReadMessage_PartitionSessionStatusResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 10);

/**
 * Command from server to create and start a partition session.
 * Client must respond with StartPartitionSessionResponse when ready to receive data from this partition.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest
 */
export type StreamReadMessage_StartPartitionSessionRequest = Message<"Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest"> & {
  /**
   * Partition session description.
   *
   * @generated from field: Ydb.Topic.StreamReadMessage.PartitionSession partition_session = 1;
   */
  partitionSession?: StreamReadMessage_PartitionSession;

  /**
   * Each offset up to and including (committed_offset - 1) was fully processed.
   *
   * @generated from field: int64 committed_offset = 2;
   */
  committedOffset: bigint;

  /**
   * Partition contains messages with offsets in range [start, end).
   *
   * @generated from field: Ydb.Topic.OffsetsRange partition_offsets = 3;
   */
  partitionOffsets?: OffsetsRange;

  /**
   * Partition location, filled only when InitRequest.direct_read is true.
   *
   * @generated from field: Ydb.Topic.PartitionLocation partition_location = 4;
   */
  partitionLocation?: PartitionLocation;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest.
 * Use `create(StreamReadMessage_StartPartitionSessionRequestSchema)` to create a new message.
 */
export const StreamReadMessage_StartPartitionSessionRequestSchema: GenMessage<StreamReadMessage_StartPartitionSessionRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 11);

/**
 * Signal for server that client is ready to recive data for partition.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.StartPartitionSessionResponse
 */
export type StreamReadMessage_StartPartitionSessionResponse = Message<"Ydb.Topic.StreamReadMessage.StartPartitionSessionResponse"> & {
  /**
   * Partition session identifier of partition to start read.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Reads in this partition session will start from offset no less than read_offset.
   * If read_offset is set, server will check that read_offset is no less that actual committed offset.
   * If check fails then server will send an error message (status != SUCCESS) and close stream.
   *
   * If read_offset is not set, no check will be made.
   * InitRequest.max_lag and InitRequest.read_from could lead to skip of more messages.
   * Server will return data starting from offset that is maximum of actual committed offset, read_offset (if set)
   * and offsets calculated from InitRequest.max_lag and InitRequest.read_from.
   *
   * @generated from field: optional int64 read_offset = 2;
   */
  readOffset?: bigint;

  /**
   * All messages with offset less than commit_offset are processed by client.
   * Server will commit this position if this is not done yet.
   *
   * @generated from field: optional int64 commit_offset = 3;
   */
  commitOffset?: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.StartPartitionSessionResponse.
 * Use `create(StreamReadMessage_StartPartitionSessionResponseSchema)` to create a new message.
 */
export const StreamReadMessage_StartPartitionSessionResponseSchema: GenMessage<StreamReadMessage_StartPartitionSessionResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 12);

/**
 * Command from server to stop and destroy concrete partition session.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.StopPartitionSessionRequest
 */
export type StreamReadMessage_StopPartitionSessionRequest = Message<"Ydb.Topic.StreamReadMessage.StopPartitionSessionRequest"> & {
  /**
   * Identifier of partition session that is ready to be closed by server.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Flag of graceful stop.
   * If set, server will wait for response from client before giving this partition to other read session.
   * Server will not send more data from this partition.
   * Client can process all received data and wait for commit and only after send response.
   * If False then server gives partition for other session right now.
   * All further commits for this partition session has no effect. Server is not waiting for response.
   *
   * @generated from field: bool graceful = 2;
   */
  graceful: boolean;

  /**
   * Upper bound for committed offsets.
   *
   * @generated from field: int64 committed_offset = 3;
   */
  committedOffset: bigint;

  /**
   * Upper bound for read request identifiers, filled only when InitRequest.direct_read is true and graceful is true.
   *
   * @generated from field: int64 last_direct_read_id = 4;
   */
  lastDirectReadId: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.StopPartitionSessionRequest.
 * Use `create(StreamReadMessage_StopPartitionSessionRequestSchema)` to create a new message.
 */
export const StreamReadMessage_StopPartitionSessionRequestSchema: GenMessage<StreamReadMessage_StopPartitionSessionRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 13);

/**
 * Signal for server that client finished working with this partition.
 * Must be sent only after corresponding StopPartitionSessionRequest from server.
 * Server will give this partition to other read session only after StopPartitionSessionResponse signal.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.StopPartitionSessionResponse
 */
export type StreamReadMessage_StopPartitionSessionResponse = Message<"Ydb.Topic.StreamReadMessage.StopPartitionSessionResponse"> & {
  /**
   * Partition session identifier of partition session that is released by client.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Flag of graceful stop, used only when InitRequest.direct_read is true
   * Client must pass this value unchanged from the StopPartitionSessionRequest.
   * Server can sent two StopPartitionSessionRequests, the first with graceful=true, the second with graceful=false. The client must answer both of them.
   *
   * @generated from field: bool graceful = 2;
   */
  graceful: boolean;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.StopPartitionSessionResponse.
 * Use `create(StreamReadMessage_StopPartitionSessionResponseSchema)` to create a new message.
 */
export const StreamReadMessage_StopPartitionSessionResponseSchema: GenMessage<StreamReadMessage_StopPartitionSessionResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 14);

/**
 * Command from server to notify about a partition session update.
 * Client should not send a response to the command.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.UpdatePartitionSession
 */
export type StreamReadMessage_UpdatePartitionSession = Message<"Ydb.Topic.StreamReadMessage.UpdatePartitionSession"> & {
  /**
   * Partition session identifier.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Partition location, filled only when InitRequest.direct_read is true.
   *
   * @generated from field: Ydb.Topic.PartitionLocation partition_location = 2;
   */
  partitionLocation?: PartitionLocation;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.UpdatePartitionSession.
 * Use `create(StreamReadMessage_UpdatePartitionSessionSchema)` to create a new message.
 */
export const StreamReadMessage_UpdatePartitionSessionSchema: GenMessage<StreamReadMessage_UpdatePartitionSession> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 15);

/**
 * Signal for server that client has finished direct reading.
 * Server should not send a response to the command.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.DirectReadAck
 */
export type StreamReadMessage_DirectReadAck = Message<"Ydb.Topic.StreamReadMessage.DirectReadAck"> & {
  /**
   * Partition session identifier.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Identifier of the successfully completed read request.
   *
   * @generated from field: int64 direct_read_id = 2;
   */
  directReadId: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.DirectReadAck.
 * Use `create(StreamReadMessage_DirectReadAckSchema)` to create a new message.
 */
export const StreamReadMessage_DirectReadAckSchema: GenMessage<StreamReadMessage_DirectReadAck> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 16);

/**
 * Signal from server that client has finished reading the partition and all messages have been read.
 * Once a partition has been finished no further messages will ever arrive to that partition.
 * This command is a hint to the client to commit offsets, after which the child partitions will be balanced independently in different reading sessions.
 * Unlike StopPartitionSessionRequest, the client does not have to close the reading session.
 * Client should not send a response to the command.
 *
 * @generated from message Ydb.Topic.StreamReadMessage.EndPartitionSession
 */
export type StreamReadMessage_EndPartitionSession = Message<"Ydb.Topic.StreamReadMessage.EndPartitionSession"> & {
  /**
   * Partition session identifier.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Ids of partitions which were merged with the ended partition.
   *
   * @generated from field: repeated int64 adjacent_partition_ids = 2;
   */
  adjacentPartitionIds: bigint[];

  /**
   * Ids of partitions which was formed when the ended partition was split or merged.
   *
   * @generated from field: repeated int64 child_partition_ids = 3;
   */
  childPartitionIds: bigint[];
};

/**
 * Describes the message Ydb.Topic.StreamReadMessage.EndPartitionSession.
 * Use `create(StreamReadMessage_EndPartitionSessionSchema)` to create a new message.
 */
export const StreamReadMessage_EndPartitionSessionSchema: GenMessage<StreamReadMessage_EndPartitionSession> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 7, 17);

/**
 * Messages for bidirectional streaming rpc StreamDirectRead
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage
 */
export type StreamDirectReadMessage = Message<"Ydb.Topic.StreamDirectReadMessage"> & {
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.
 * Use `create(StreamDirectReadMessageSchema)` to create a new message.
 */
export const StreamDirectReadMessageSchema: GenMessage<StreamDirectReadMessage> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8);

/**
 * Client-server message for direct read session.
 *     InitRequest - command from client to create and start a direct read session.
 *     StartDirectReadPartitionSessionRequest - command from client to create and start a direct read partition session.
 *         Client signals it is ready to get data from partition.
 *     UpdateTokenRequest - request to update auth token
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage.FromClient
 */
export type StreamDirectReadMessage_FromClient = Message<"Ydb.Topic.StreamDirectReadMessage.FromClient"> & {
  /**
   * @generated from oneof Ydb.Topic.StreamDirectReadMessage.FromClient.client_message
   */
  clientMessage: {
    /**
     * @generated from field: Ydb.Topic.StreamDirectReadMessage.InitRequest init_request = 1;
     */
    value: StreamDirectReadMessage_InitRequest;
    case: "initRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequest start_direct_read_partition_session_request = 2;
     */
    value: StreamDirectReadMessage_StartDirectReadPartitionSessionRequest;
    case: "startDirectReadPartitionSessionRequest";
  } | {
    /**
     * @generated from field: Ydb.Topic.UpdateTokenRequest update_token_request = 3;
     */
    value: UpdateTokenRequest;
    case: "updateTokenRequest";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.FromClient.
 * Use `create(StreamDirectReadMessage_FromClientSchema)` to create a new message.
 */
export const StreamDirectReadMessage_FromClientSchema: GenMessage<StreamDirectReadMessage_FromClient> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 0);

/**
 * Server-client message for direct read session.
 *     InitResponse - correct handshake response.
 *     StartDirectReadPartitionSessionResponse - Response to StartDirectReadPartitionSessionRequest.
 *     DirectReadResponse - portion of message data.
 *     StopDirectReadPartitionSession - command from server to stop a direct read partition session.
 *     UpdateTokenResponse - acknowledgment of token update.
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage.FromServer
 */
export type StreamDirectReadMessage_FromServer = Message<"Ydb.Topic.StreamDirectReadMessage.FromServer"> & {
  /**
   * Server status of response.
   *
   * @generated from field: Ydb.StatusIds.StatusCode status = 1;
   */
  status: StatusIds_StatusCode;

  /**
   * Issues if any.
   *
   * @generated from field: repeated Ydb.Issue.IssueMessage issues = 2;
   */
  issues: IssueMessage[];

  /**
   * @generated from oneof Ydb.Topic.StreamDirectReadMessage.FromServer.server_message
   */
  serverMessage: {
    /**
     * @generated from field: Ydb.Topic.StreamDirectReadMessage.InitResponse init_response = 6;
     */
    value: StreamDirectReadMessage_InitResponse;
    case: "initResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponse start_direct_read_partition_session_response = 7;
     */
    value: StreamDirectReadMessage_StartDirectReadPartitionSessionResponse;
    case: "startDirectReadPartitionSessionResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession stop_direct_read_partition_session = 3;
     */
    value: StreamDirectReadMessage_StopDirectReadPartitionSession;
    case: "stopDirectReadPartitionSession";
  } | {
    /**
     * @generated from field: Ydb.Topic.StreamDirectReadMessage.DirectReadResponse direct_read_response = 4;
     */
    value: StreamDirectReadMessage_DirectReadResponse;
    case: "directReadResponse";
  } | {
    /**
     * @generated from field: Ydb.Topic.UpdateTokenResponse update_token_response = 5;
     */
    value: UpdateTokenResponse;
    case: "updateTokenResponse";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.FromServer.
 * Use `create(StreamDirectReadMessage_FromServerSchema)` to create a new message.
 */
export const StreamDirectReadMessage_FromServerSchema: GenMessage<StreamDirectReadMessage_FromServer> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 1);

/**
 * Command from client to create and start a direct read session.
 * Server should not send a response to the command.
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage.InitRequest
 */
export type StreamDirectReadMessage_InitRequest = Message<"Ydb.Topic.StreamDirectReadMessage.InitRequest"> & {
  /**
   * Read session identifier.
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * Topics that will be read by this session.
   *
   * @generated from field: repeated Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettings topics_read_settings = 2;
   */
  topicsReadSettings: StreamDirectReadMessage_InitRequest_TopicReadSettings[];

  /**
   * Path of consumer that is used for reading by this session.
   *
   * @generated from field: string consumer = 3;
   */
  consumer: string;
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.InitRequest.
 * Use `create(StreamDirectReadMessage_InitRequestSchema)` to create a new message.
 */
export const StreamDirectReadMessage_InitRequestSchema: GenMessage<StreamDirectReadMessage_InitRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 2);

/**
 * @generated from message Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettings
 */
export type StreamDirectReadMessage_InitRequest_TopicReadSettings = Message<"Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettings"> & {
  /**
   * Topic path.
   *
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettings.
 * Use `create(StreamDirectReadMessage_InitRequest_TopicReadSettingsSchema)` to create a new message.
 */
export const StreamDirectReadMessage_InitRequest_TopicReadSettingsSchema: GenMessage<StreamDirectReadMessage_InitRequest_TopicReadSettings> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 2, 0);

/**
 * Response to the handshake.
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage.InitResponse
 */
export type StreamDirectReadMessage_InitResponse = Message<"Ydb.Topic.StreamDirectReadMessage.InitResponse"> & {
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.InitResponse.
 * Use `create(StreamDirectReadMessage_InitResponseSchema)` to create a new message.
 */
export const StreamDirectReadMessage_InitResponseSchema: GenMessage<StreamDirectReadMessage_InitResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 3);

/**
 * Command from client to create and start a direct read partition session.
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequest
 */
export type StreamDirectReadMessage_StartDirectReadPartitionSessionRequest = Message<"Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequest"> & {
  /**
   * Partition session identifier.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Upper bound for read request identifiers.
   *
   * @generated from field: int64 last_direct_read_id = 2;
   */
  lastDirectReadId: bigint;

  /**
   * Partition generation.
   *
   * @generated from field: int64 generation = 3;
   */
  generation: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequest.
 * Use `create(StreamDirectReadMessage_StartDirectReadPartitionSessionRequestSchema)` to create a new message.
 */
export const StreamDirectReadMessage_StartDirectReadPartitionSessionRequestSchema: GenMessage<StreamDirectReadMessage_StartDirectReadPartitionSessionRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 4);

/**
 * Signal for server that client is ready to receive data for partition.
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponse
 */
export type StreamDirectReadMessage_StartDirectReadPartitionSessionResponse = Message<"Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponse"> & {
  /**
   * Partition session identifier of partition to start read.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Partition generation.
   *
   * @generated from field: int64 generation = 2;
   */
  generation: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponse.
 * Use `create(StreamDirectReadMessage_StartDirectReadPartitionSessionResponseSchema)` to create a new message.
 */
export const StreamDirectReadMessage_StartDirectReadPartitionSessionResponseSchema: GenMessage<StreamDirectReadMessage_StartDirectReadPartitionSessionResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 5);

/**
 * Command from server to stop a direct read partition session.
 * Client should not send a response to the command.
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession
 */
export type StreamDirectReadMessage_StopDirectReadPartitionSession = Message<"Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession"> & {
  /**
   * The reason for the stop.
   *
   * @generated from field: Ydb.StatusIds.StatusCode status = 1;
   */
  status: StatusIds_StatusCode;

  /**
   * Issues if any.
   *
   * @generated from field: repeated Ydb.Issue.IssueMessage issues = 2;
   */
  issues: IssueMessage[];

  /**
   * Partition session identifier.
   *
   * @generated from field: int64 partition_session_id = 3;
   */
  partitionSessionId: bigint;

  /**
   * Partition generation.
   *
   * @generated from field: int64 generation = 4;
   */
  generation: bigint;
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession.
 * Use `create(StreamDirectReadMessage_StopDirectReadPartitionSessionSchema)` to create a new message.
 */
export const StreamDirectReadMessage_StopDirectReadPartitionSessionSchema: GenMessage<StreamDirectReadMessage_StopDirectReadPartitionSession> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 6);

/**
 * Messages that have been read directly from the partition node.
 * It's a response to StreamRead.ReadRequest
 *
 * @generated from message Ydb.Topic.StreamDirectReadMessage.DirectReadResponse
 */
export type StreamDirectReadMessage_DirectReadResponse = Message<"Ydb.Topic.StreamDirectReadMessage.DirectReadResponse"> & {
  /**
   * Partition session identifier.
   *
   * @generated from field: int64 partition_session_id = 1;
   */
  partitionSessionId: bigint;

  /**
   * Read request identifier.
   *
   * @generated from field: int64 direct_read_id = 2;
   */
  directReadId: bigint;

  /**
   * Messages data
   *
   * @generated from field: Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData partition_data = 3;
   */
  partitionData?: StreamReadMessage_ReadResponse_PartitionData;
};

/**
 * Describes the message Ydb.Topic.StreamDirectReadMessage.DirectReadResponse.
 * Use `create(StreamDirectReadMessage_DirectReadResponseSchema)` to create a new message.
 */
export const StreamDirectReadMessage_DirectReadResponseSchema: GenMessage<StreamDirectReadMessage_DirectReadResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 8, 7);

/**
 * @generated from message Ydb.Topic.TransactionIdentity
 */
export type TransactionIdentity = Message<"Ydb.Topic.TransactionIdentity"> & {
  /**
   * Transaction identifier from TableService.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Session identifier from TableService.
   *
   * @generated from field: string session = 2;
   */
  session: string;
};

/**
 * Describes the message Ydb.Topic.TransactionIdentity.
 * Use `create(TransactionIdentitySchema)` to create a new message.
 */
export const TransactionIdentitySchema: GenMessage<TransactionIdentity> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 9);

/**
 * Add offsets to transaction request sent from client to server.
 *
 * @generated from message Ydb.Topic.UpdateOffsetsInTransactionRequest
 */
export type UpdateOffsetsInTransactionRequest = Message<"Ydb.Topic.UpdateOffsetsInTransactionRequest"> & {
  /**
   * @generated from field: Ydb.Operations.OperationParams operation_params = 1;
   */
  operationParams?: OperationParams;

  /**
   * @generated from field: Ydb.Topic.TransactionIdentity tx = 2;
   */
  tx?: TransactionIdentity;

  /**
   * Ranges of offsets by topics.
   *
   * @generated from field: repeated Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets topics = 3;
   */
  topics: UpdateOffsetsInTransactionRequest_TopicOffsets[];

  /**
   * @generated from field: string consumer = 4;
   */
  consumer: string;
};

/**
 * Describes the message Ydb.Topic.UpdateOffsetsInTransactionRequest.
 * Use `create(UpdateOffsetsInTransactionRequestSchema)` to create a new message.
 */
export const UpdateOffsetsInTransactionRequestSchema: GenMessage<UpdateOffsetsInTransactionRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 10);

/**
 * @generated from message Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets
 */
export type UpdateOffsetsInTransactionRequest_TopicOffsets = Message<"Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets"> & {
  /**
   * Topic path.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Ranges of offsets by partitions.
   *
   * @generated from field: repeated Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets partitions = 2;
   */
  partitions: UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets[];
};

/**
 * Describes the message Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.
 * Use `create(UpdateOffsetsInTransactionRequest_TopicOffsetsSchema)` to create a new message.
 */
export const UpdateOffsetsInTransactionRequest_TopicOffsetsSchema: GenMessage<UpdateOffsetsInTransactionRequest_TopicOffsets> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 10, 0);

/**
 * @generated from message Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets
 */
export type UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets = Message<"Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets"> & {
  /**
   * Partition identifier.
   *
   * @generated from field: int64 partition_id = 1;
   */
  partitionId: bigint;

  /**
   * List of offset ranges.
   *
   * @generated from field: repeated Ydb.Topic.OffsetsRange partition_offsets = 2;
   */
  partitionOffsets: OffsetsRange[];
};

/**
 * Describes the message Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets.
 * Use `create(UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsetsSchema)` to create a new message.
 */
export const UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsetsSchema: GenMessage<UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 10, 0, 0);

/**
 * Add offsets to transaction response sent from server to client.
 *
 * @generated from message Ydb.Topic.UpdateOffsetsInTransactionResponse
 */
export type UpdateOffsetsInTransactionResponse = Message<"Ydb.Topic.UpdateOffsetsInTransactionResponse"> & {
  /**
   * Result of request will be inside operation.
   *
   * @generated from field: Ydb.Operations.Operation operation = 1;
   */
  operation?: Operation;
};

/**
 * Describes the message Ydb.Topic.UpdateOffsetsInTransactionResponse.
 * Use `create(UpdateOffsetsInTransactionResponseSchema)` to create a new message.
 */
export const UpdateOffsetsInTransactionResponseSchema: GenMessage<UpdateOffsetsInTransactionResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 11);

/**
 * Add offsets to transaction result message that will be inside UpdateOffsetsInTransactionResponse.operation.
 *
 * @generated from message Ydb.Topic.UpdateOffsetsInTransactionResult
 */
export type UpdateOffsetsInTransactionResult = Message<"Ydb.Topic.UpdateOffsetsInTransactionResult"> & {
};

/**
 * Describes the message Ydb.Topic.UpdateOffsetsInTransactionResult.
 * Use `create(UpdateOffsetsInTransactionResultSchema)` to create a new message.
 */
export const UpdateOffsetsInTransactionResultSchema: GenMessage<UpdateOffsetsInTransactionResult> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 12);

/**
 * Commit offset request sent from client to server.
 *
 * @generated from message Ydb.Topic.CommitOffsetRequest
 */
export type CommitOffsetRequest = Message<"Ydb.Topic.CommitOffsetRequest"> & {
  /**
   * @generated from field: Ydb.Operations.OperationParams operation_params = 1;
   */
  operationParams?: OperationParams;

  /**
   * Topic path of partition.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Partition identifier.
   *
   * @generated from field: int64 partition_id = 3;
   */
  partitionId: bigint;

  /**
   * Path of consumer.
   *
   * @generated from field: string consumer = 4;
   */
  consumer: string;

  /**
   * Processed offset.
   *
   * @generated from field: int64 offset = 5;
   */
  offset: bigint;
};

/**
 * Describes the message Ydb.Topic.CommitOffsetRequest.
 * Use `create(CommitOffsetRequestSchema)` to create a new message.
 */
export const CommitOffsetRequestSchema: GenMessage<CommitOffsetRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 13);

/**
 * Commit offset response sent from server to client.
 *
 * @generated from message Ydb.Topic.CommitOffsetResponse
 */
export type CommitOffsetResponse = Message<"Ydb.Topic.CommitOffsetResponse"> & {
  /**
   * Result of request will be inside operation.
   *
   * @generated from field: Ydb.Operations.Operation operation = 1;
   */
  operation?: Operation;
};

/**
 * Describes the message Ydb.Topic.CommitOffsetResponse.
 * Use `create(CommitOffsetResponseSchema)` to create a new message.
 */
export const CommitOffsetResponseSchema: GenMessage<CommitOffsetResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 14);

/**
 * Commit offset result message inside CommitOffsetResponse.operation.
 *
 * @generated from message Ydb.Topic.CommitOffsetResult
 */
export type CommitOffsetResult = Message<"Ydb.Topic.CommitOffsetResult"> & {
};

/**
 * Describes the message Ydb.Topic.CommitOffsetResult.
 * Use `create(CommitOffsetResultSchema)` to create a new message.
 */
export const CommitOffsetResultSchema: GenMessage<CommitOffsetResult> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 15);

/**
 * message representing statistics by several windows
 *
 * @generated from message Ydb.Topic.MultipleWindowsStat
 */
export type MultipleWindowsStat = Message<"Ydb.Topic.MultipleWindowsStat"> & {
  /**
   * @generated from field: int64 per_minute = 1;
   */
  perMinute: bigint;

  /**
   * @generated from field: int64 per_hour = 2;
   */
  perHour: bigint;

  /**
   * @generated from field: int64 per_day = 3;
   */
  perDay: bigint;
};

/**
 * Describes the message Ydb.Topic.MultipleWindowsStat.
 * Use `create(MultipleWindowsStatSchema)` to create a new message.
 */
export const MultipleWindowsStatSchema: GenMessage<MultipleWindowsStat> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 16);

/**
 * Consumer description.
 *
 * @generated from message Ydb.Topic.Consumer
 */
export type Consumer = Message<"Ydb.Topic.Consumer"> & {
  /**
   * Must have valid not empty name as a key.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Consumer may be marked as 'important'. It means messages for this consumer will never expire due to retention.
   * User should take care that such consumer never stalls, to prevent running out of disk space.
   * Flag that this consumer is important.
   *
   * @generated from field: bool important = 2;
   */
  important: boolean;

  /**
   * All messages with smaller server written_at timestamp will be skipped.
   *
   * @generated from field: google.protobuf.Timestamp read_from = 3;
   */
  readFrom?: Timestamp;

  /**
   * List of supported codecs by this consumer.
   * supported_codecs on topic must be contained inside this list.
   * If empty, codec compatibility check for the consumer is disabled.
   *
   * @generated from field: Ydb.Topic.SupportedCodecs supported_codecs = 5;
   */
  supportedCodecs?: SupportedCodecs;

  /**
   * Attributes of consumer
   *
   * @generated from field: map<string, string> attributes = 6;
   */
  attributes: { [key: string]: string };

  /**
   * Filled only when requested statistics in Describe*Request.
   *
   * @generated from field: Ydb.Topic.Consumer.ConsumerStats consumer_stats = 7;
   */
  consumerStats?: Consumer_ConsumerStats;
};

/**
 * Describes the message Ydb.Topic.Consumer.
 * Use `create(ConsumerSchema)` to create a new message.
 */
export const ConsumerSchema: GenMessage<Consumer> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 17);

/**
 * @generated from message Ydb.Topic.Consumer.ConsumerStats
 */
export type Consumer_ConsumerStats = Message<"Ydb.Topic.Consumer.ConsumerStats"> & {
  /**
   * Minimal timestamp of last read from partitions.
   *
   * @generated from field: google.protobuf.Timestamp min_partitions_last_read_time = 1;
   */
  minPartitionsLastReadTime?: Timestamp;

  /**
   * Maximum of differences between timestamp of read and write timestamp for all messages, read during last minute.
   *
   * @generated from field: google.protobuf.Duration max_read_time_lag = 2;
   */
  maxReadTimeLag?: Duration;

  /**
   * Maximum of differences between write timestamp and create timestamp for all messages, read during last minute.
   *
   * @generated from field: google.protobuf.Duration max_write_time_lag = 3;
   */
  maxWriteTimeLag?: Duration;

  /**
   * Bytes read statistics.
   *
   * @generated from field: Ydb.Topic.MultipleWindowsStat bytes_read = 4;
   */
  bytesRead?: MultipleWindowsStat;
};

/**
 * Describes the message Ydb.Topic.Consumer.ConsumerStats.
 * Use `create(Consumer_ConsumerStatsSchema)` to create a new message.
 */
export const Consumer_ConsumerStatsSchema: GenMessage<Consumer_ConsumerStats> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 17, 0);

/**
 * Consumer alter description.
 *
 * @generated from message Ydb.Topic.AlterConsumer
 */
export type AlterConsumer = Message<"Ydb.Topic.AlterConsumer"> & {
  /**
   * Must have valid not empty name as a key.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Consumer may be marked as 'important'. It means messages for this consumer will never expire due to retention.
   * User should take care that such consumer never stalls, to prevent running out of disk space.
   * Flag that this consumer is important.
   *
   * @generated from field: optional bool set_important = 2;
   */
  setImportant?: boolean;

  /**
   * All messages with smaller server written_at timestamp will be skipped.
   *
   * @generated from field: google.protobuf.Timestamp set_read_from = 3;
   */
  setReadFrom?: Timestamp;

  /**
   * List of supported codecs by this consumer.
   * supported_codecs on topic must be contained inside this list.
   * If empty, codec compatibility check for the consumer is disabled.
   *
   * @generated from field: Ydb.Topic.SupportedCodecs set_supported_codecs = 5;
   */
  setSupportedCodecs?: SupportedCodecs;

  /**
   * User and server attributes of consumer. Server attributes starts from "_" and will be validated by server.
   * Leave the value blank to drop an attribute.
   *
   * @generated from field: map<string, string> alter_attributes = 6;
   */
  alterAttributes: { [key: string]: string };
};

/**
 * Describes the message Ydb.Topic.AlterConsumer.
 * Use `create(AlterConsumerSchema)` to create a new message.
 */
export const AlterConsumerSchema: GenMessage<AlterConsumer> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 18);

/**
 * Partitioning settings for topic.
 *
 * @generated from message Ydb.Topic.PartitioningSettings
 */
export type PartitioningSettings = Message<"Ydb.Topic.PartitioningSettings"> & {
  /**
   * Auto merge would stop working when the partitions count reaches min_active_partitions
   * Zero value means default - 1.
   *
   * @generated from field: int64 min_active_partitions = 1;
   */
  minActivePartitions: bigint;

  /**
   * Auto split would stop working when the partitions count reaches max_active_partitions
   * Zero value means default - 1.
   *
   * @generated from field: int64 max_active_partitions = 3;
   */
  maxActivePartitions: bigint;

  /**
   * Limit for total partition count, including active (open for write) and read-only partitions.
   * Zero value means default - 100.
   * Use max_active_partitions
   *
   * @generated from field: int64 partition_count_limit = 2 [deprecated = true];
   * @deprecated
   */
  partitionCountLimit: bigint;

  /**
   * Settings for the partitions count auto partitioning.
   *
   * @generated from field: Ydb.Topic.AutoPartitioningSettings auto_partitioning_settings = 4;
   */
  autoPartitioningSettings?: AutoPartitioningSettings;
};

/**
 * Describes the message Ydb.Topic.PartitioningSettings.
 * Use `create(PartitioningSettingsSchema)` to create a new message.
 */
export const PartitioningSettingsSchema: GenMessage<PartitioningSettings> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 19);

/**
 * @generated from message Ydb.Topic.AutoPartitioningSettings
 */
export type AutoPartitioningSettings = Message<"Ydb.Topic.AutoPartitioningSettings"> & {
  /**
   * Strategy of auto partitioning.
   *
   * @generated from field: Ydb.Topic.AutoPartitioningStrategy strategy = 1;
   */
  strategy: AutoPartitioningStrategy;

  /**
   * Partition write speed auto partitioning options.
   *
   * @generated from field: Ydb.Topic.AutoPartitioningWriteSpeedStrategy partition_write_speed = 2;
   */
  partitionWriteSpeed?: AutoPartitioningWriteSpeedStrategy;
};

/**
 * Describes the message Ydb.Topic.AutoPartitioningSettings.
 * Use `create(AutoPartitioningSettingsSchema)` to create a new message.
 */
export const AutoPartitioningSettingsSchema: GenMessage<AutoPartitioningSettings> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 20);

/**
 * Partition will be auto partitioned up (divided into 2 partitions)
 * after write speed to the partition exceeds up_utilization_percent (in percentage of maximum write speed to the partition) for the period of time stabilization_window
 *
 * @generated from message Ydb.Topic.AutoPartitioningWriteSpeedStrategy
 */
export type AutoPartitioningWriteSpeedStrategy = Message<"Ydb.Topic.AutoPartitioningWriteSpeedStrategy"> & {
  /**
   * Zero value means default - 300.
   *
   * @generated from field: google.protobuf.Duration stabilization_window = 1;
   */
  stabilizationWindow?: Duration;

  /**
   * Zero value means default - 90.
   *
   * @generated from field: int32 up_utilization_percent = 2;
   */
  upUtilizationPercent: number;

  /**
   * Zero value means default - 30.
   *
   * @generated from field: int32 down_utilization_percent = 3;
   */
  downUtilizationPercent: number;
};

/**
 * Describes the message Ydb.Topic.AutoPartitioningWriteSpeedStrategy.
 * Use `create(AutoPartitioningWriteSpeedStrategySchema)` to create a new message.
 */
export const AutoPartitioningWriteSpeedStrategySchema: GenMessage<AutoPartitioningWriteSpeedStrategy> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 21);

/**
 * Partitioning settings for topic.
 *
 * @generated from message Ydb.Topic.AlterPartitioningSettings
 */
export type AlterPartitioningSettings = Message<"Ydb.Topic.AlterPartitioningSettings"> & {
  /**
   * Minimum partition count auto merge would stop working at.
   * Zero value means default - 1.
   *
   * @generated from field: optional int64 set_min_active_partitions = 1;
   */
  setMinActivePartitions?: bigint;

  /**
   * Maximum partition count auto merge would stop working at.
   * Zero value means default - 1.
   *
   * @generated from field: optional int64 set_max_active_partitions = 3;
   */
  setMaxActivePartitions?: bigint;

  /**
   * Limit for total partition count, including active (open for write) and read-only partitions.
   * Zero value means default - 100.
   * Use set_max_active_partitions
   *
   * @generated from field: optional int64 set_partition_count_limit = 2 [deprecated = true];
   * @deprecated
   */
  setPartitionCountLimit?: bigint;

  /**
   * Settings for auto partitioning the partition number
   *
   * @generated from field: optional Ydb.Topic.AlterAutoPartitioningSettings alter_auto_partitioning_settings = 4;
   */
  alterAutoPartitioningSettings?: AlterAutoPartitioningSettings;
};

/**
 * Describes the message Ydb.Topic.AlterPartitioningSettings.
 * Use `create(AlterPartitioningSettingsSchema)` to create a new message.
 */
export const AlterPartitioningSettingsSchema: GenMessage<AlterPartitioningSettings> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 22);

/**
 * @generated from message Ydb.Topic.AlterAutoPartitioningSettings
 */
export type AlterAutoPartitioningSettings = Message<"Ydb.Topic.AlterAutoPartitioningSettings"> & {
  /**
   * Strategy of auto partitioning
   *
   * @generated from field: optional Ydb.Topic.AutoPartitioningStrategy set_strategy = 1;
   */
  setStrategy?: AutoPartitioningStrategy;

  /**
   * Auto partitioning write speed options.
   *
   * @generated from field: optional Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy set_partition_write_speed = 2;
   */
  setPartitionWriteSpeed?: AlterAutoPartitioningWriteSpeedStrategy;
};

/**
 * Describes the message Ydb.Topic.AlterAutoPartitioningSettings.
 * Use `create(AlterAutoPartitioningSettingsSchema)` to create a new message.
 */
export const AlterAutoPartitioningSettingsSchema: GenMessage<AlterAutoPartitioningSettings> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 23);

/**
 * @generated from message Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy
 */
export type AlterAutoPartitioningWriteSpeedStrategy = Message<"Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy"> & {
  /**
   * The time of exceeding the threshold value, after which the partition will be
   * auto partitioning.
   * Zero value means default - 300.
   *
   * @generated from field: optional google.protobuf.Duration set_stabilization_window = 1;
   */
  setStabilizationWindow?: Duration;

  /**
   * The threshold value of the write speed to the partition as a percentage, when exceeded,
   * the partition will be auto split.
   * Zero value means default - 90.
   *
   * @generated from field: optional int32 set_up_utilization_percent = 2;
   */
  setUpUtilizationPercent?: number;

  /**
   * The threshold value of the write speed to the partition as a percentage, if it is not reached,
   * the partition will be auto merged.
   * Zero value means default - 30.
   *
   * @generated from field: optional int32 set_down_utilization_percent = 3;
   */
  setDownUtilizationPercent?: number;
};

/**
 * Describes the message Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy.
 * Use `create(AlterAutoPartitioningWriteSpeedStrategySchema)` to create a new message.
 */
export const AlterAutoPartitioningWriteSpeedStrategySchema: GenMessage<AlterAutoPartitioningWriteSpeedStrategy> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 24);

/**
 * Create topic request sent from client to server.
 *
 * @generated from message Ydb.Topic.CreateTopicRequest
 */
export type CreateTopicRequest = Message<"Ydb.Topic.CreateTopicRequest"> & {
  /**
   * @generated from field: Ydb.Operations.OperationParams operation_params = 1;
   */
  operationParams?: OperationParams;

  /**
   * Topic path.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Settings for partitioning
   *
   * @generated from field: Ydb.Topic.PartitioningSettings partitioning_settings = 3;
   */
  partitioningSettings?: PartitioningSettings;

  /**
   * Retention settings.
   * Currently, only one limit may be set, so other should not be set.
   *
   * How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
   * Default limit - 36 hours.
   *
   * @generated from field: google.protobuf.Duration retention_period = 4;
   */
  retentionPeriod?: Duration;

  /**
   * How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
   * Zero value means infinite limit.
   *
   * @generated from field: int64 retention_storage_mb = 5;
   */
  retentionStorageMb: bigint;

  /**
   * List of allowed codecs for writers.
   * Writes with codec not from this list are forbidden.
   * If empty, codec compatibility check for the topic is disabled.
   *
   * @generated from field: Ydb.Topic.SupportedCodecs supported_codecs = 7;
   */
  supportedCodecs?: SupportedCodecs;

  /**
   * Partition write speed in bytes per second. Must be less than database limit.
   * Zero value means default limit: 1 MB per second.
   *
   * @generated from field: int64 partition_write_speed_bytes_per_second = 8;
   */
  partitionWriteSpeedBytesPerSecond: bigint;

  /**
   * Burst size for write in partition, in bytes. Must be less than database limit.
   * Zero value means default limit: 1 MB.
   *
   * @generated from field: int64 partition_write_burst_bytes = 9;
   */
  partitionWriteBurstBytes: bigint;

  /**
   * User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
   *
   * @generated from field: map<string, string> attributes = 10;
   */
  attributes: { [key: string]: string };

  /**
   * List of consumers for this topic.
   *
   * @generated from field: repeated Ydb.Topic.Consumer consumers = 11;
   */
  consumers: Consumer[];

  /**
   * Metering mode for the topic in a serverless database.
   *
   * @generated from field: Ydb.Topic.MeteringMode metering_mode = 12;
   */
  meteringMode: MeteringMode;
};

/**
 * Describes the message Ydb.Topic.CreateTopicRequest.
 * Use `create(CreateTopicRequestSchema)` to create a new message.
 */
export const CreateTopicRequestSchema: GenMessage<CreateTopicRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 25);

/**
 * Create topic response sent from server to client.
 * If topic is already exists then response status will be "ALREADY_EXISTS".
 *
 * @generated from message Ydb.Topic.CreateTopicResponse
 */
export type CreateTopicResponse = Message<"Ydb.Topic.CreateTopicResponse"> & {
  /**
   * Result of request will be inside operation.
   *
   * @generated from field: Ydb.Operations.Operation operation = 1;
   */
  operation?: Operation;
};

/**
 * Describes the message Ydb.Topic.CreateTopicResponse.
 * Use `create(CreateTopicResponseSchema)` to create a new message.
 */
export const CreateTopicResponseSchema: GenMessage<CreateTopicResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 26);

/**
 * Create topic result message that will be inside CreateTopicResponse.operation.
 *
 * @generated from message Ydb.Topic.CreateTopicResult
 */
export type CreateTopicResult = Message<"Ydb.Topic.CreateTopicResult"> & {
};

/**
 * Describes the message Ydb.Topic.CreateTopicResult.
 * Use `create(CreateTopicResultSchema)` to create a new message.
 */
export const CreateTopicResultSchema: GenMessage<CreateTopicResult> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 27);

/**
 * Topic partition location
 *
 * @generated from message Ydb.Topic.PartitionLocation
 */
export type PartitionLocation = Message<"Ydb.Topic.PartitionLocation"> & {
  /**
   * Node identificator.
   *
   * @generated from field: int32 node_id = 1;
   */
  nodeId: number;

  /**
   * Partition generation.
   *
   * @generated from field: int64 generation = 2;
   */
  generation: bigint;
};

/**
 * Describes the message Ydb.Topic.PartitionLocation.
 * Use `create(PartitionLocationSchema)` to create a new message.
 */
export const PartitionLocationSchema: GenMessage<PartitionLocation> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 28);

/**
 * Describe topic request sent from client to server.
 *
 * @generated from message Ydb.Topic.DescribeTopicRequest
 */
export type DescribeTopicRequest = Message<"Ydb.Topic.DescribeTopicRequest"> & {
  /**
   * @generated from field: Ydb.Operations.OperationParams operation_params = 1;
   */
  operationParams?: OperationParams;

  /**
   * Topic path.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Include topic statistics.
   *
   * @generated from field: bool include_stats = 3;
   */
  includeStats: boolean;

  /**
   * Include partition location.
   *
   * @generated from field: bool include_location = 4;
   */
  includeLocation: boolean;
};

/**
 * Describes the message Ydb.Topic.DescribeTopicRequest.
 * Use `create(DescribeTopicRequestSchema)` to create a new message.
 */
export const DescribeTopicRequestSchema: GenMessage<DescribeTopicRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 29);

/**
 * Describe topic response sent from server to client.
 * If topic is not existed then response status will be "SCHEME_ERROR".
 *
 * @generated from message Ydb.Topic.DescribeTopicResponse
 */
export type DescribeTopicResponse = Message<"Ydb.Topic.DescribeTopicResponse"> & {
  /**
   * Result of request will be inside operation.
   *
   * @generated from field: Ydb.Operations.Operation operation = 1;
   */
  operation?: Operation;
};

/**
 * Describes the message Ydb.Topic.DescribeTopicResponse.
 * Use `create(DescribeTopicResponseSchema)` to create a new message.
 */
export const DescribeTopicResponseSchema: GenMessage<DescribeTopicResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 30);

/**
 * @generated from message Ydb.Topic.PartitionKeyRange
 */
export type PartitionKeyRange = Message<"Ydb.Topic.PartitionKeyRange"> & {
  /**
   * Inclusive left border. Emptiness means -inf.
   *
   * @generated from field: optional bytes from_bound = 1;
   */
  fromBound?: Uint8Array;

  /**
   * Exclusive right border. Emptiness means +inf.
   *
   * @generated from field: optional bytes to_bound = 2;
   */
  toBound?: Uint8Array;
};

/**
 * Describes the message Ydb.Topic.PartitionKeyRange.
 * Use `create(PartitionKeyRangeSchema)` to create a new message.
 */
export const PartitionKeyRangeSchema: GenMessage<PartitionKeyRange> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 31);

/**
 * Describe topic result message that will be inside DescribeTopicResponse.operation.
 *
 * @generated from message Ydb.Topic.DescribeTopicResult
 */
export type DescribeTopicResult = Message<"Ydb.Topic.DescribeTopicResult"> & {
  /**
   * Description of scheme object.
   *
   * @generated from field: Ydb.Scheme.Entry self = 1;
   */
  self?: Entry;

  /**
   * Settings for partitioning
   *
   * @generated from field: Ydb.Topic.PartitioningSettings partitioning_settings = 2;
   */
  partitioningSettings?: PartitioningSettings;

  /**
   * Partitions description.
   *
   * @generated from field: repeated Ydb.Topic.DescribeTopicResult.PartitionInfo partitions = 3;
   */
  partitions: DescribeTopicResult_PartitionInfo[];

  /**
   * Retention settings.
   * Currently, only one limit may be set, so other should not be set.
   *
   * How long data in partition should be stored.
   *
   * @generated from field: google.protobuf.Duration retention_period = 4;
   */
  retentionPeriod?: Duration;

  /**
   * How much data in partition should be stored.
   * Zero value means infinite limit.
   *
   * @generated from field: int64 retention_storage_mb = 5;
   */
  retentionStorageMb: bigint;

  /**
   * List of allowed codecs for writers.
   * Writes with codec not from this list are forbidden.
   * If empty, codec compatibility check for the topic is disabled.
   *
   * @generated from field: Ydb.Topic.SupportedCodecs supported_codecs = 7;
   */
  supportedCodecs?: SupportedCodecs;

  /**
   * Partition write speed in bytes per second.
   * Zero value means default limit: 1 MB per second.
   *
   * @generated from field: int64 partition_write_speed_bytes_per_second = 8;
   */
  partitionWriteSpeedBytesPerSecond: bigint;

  /**
   * @generated from field: int64 partition_total_read_speed_bytes_per_second = 14;
   */
  partitionTotalReadSpeedBytesPerSecond: bigint;

  /**
   * @generated from field: int64 partition_consumer_read_speed_bytes_per_second = 15;
   */
  partitionConsumerReadSpeedBytesPerSecond: bigint;

  /**
   * Burst size for write in partition, in bytes.
   * Zero value means default limit: 1 MB.
   *
   * @generated from field: int64 partition_write_burst_bytes = 9;
   */
  partitionWriteBurstBytes: bigint;

  /**
   * User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
   *
   * @generated from field: map<string, string> attributes = 10;
   */
  attributes: { [key: string]: string };

  /**
   * List of consumers for this topic.
   *
   * @generated from field: repeated Ydb.Topic.Consumer consumers = 11;
   */
  consumers: Consumer[];

  /**
   * Metering settings.
   *
   * @generated from field: Ydb.Topic.MeteringMode metering_mode = 12;
   */
  meteringMode: MeteringMode;

  /**
   * Statistics of topic.
   *
   * @generated from field: Ydb.Topic.DescribeTopicResult.TopicStats topic_stats = 13;
   */
  topicStats?: DescribeTopicResult_TopicStats;
};

/**
 * Describes the message Ydb.Topic.DescribeTopicResult.
 * Use `create(DescribeTopicResultSchema)` to create a new message.
 */
export const DescribeTopicResultSchema: GenMessage<DescribeTopicResult> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 32);

/**
 * @generated from message Ydb.Topic.DescribeTopicResult.PartitionInfo
 */
export type DescribeTopicResult_PartitionInfo = Message<"Ydb.Topic.DescribeTopicResult.PartitionInfo"> & {
  /**
   * Partition identifier.
   *
   * @generated from field: int64 partition_id = 1;
   */
  partitionId: bigint;

  /**
   * Is partition open for write.
   *
   * @generated from field: bool active = 2;
   */
  active: boolean;

  /**
   * Ids of partitions which was formed when this partition was split or merged.
   *
   * @generated from field: repeated int64 child_partition_ids = 3;
   */
  childPartitionIds: bigint[];

  /**
   * Ids of partitions from which this partition was formed by split or merge.
   *
   * @generated from field: repeated int64 parent_partition_ids = 4;
   */
  parentPartitionIds: bigint[];

  /**
   * Stats for partition, filled only when include_stats in request is true.
   *
   * @generated from field: Ydb.Topic.PartitionStats partition_stats = 5;
   */
  partitionStats?: PartitionStats;

  /**
   * Partition location, filled only when include_location in request is true.
   *
   * @generated from field: Ydb.Topic.PartitionLocation partition_location = 6;
   */
  partitionLocation?: PartitionLocation;

  /**
   * @generated from field: Ydb.Topic.PartitionKeyRange key_range = 7;
   */
  keyRange?: PartitionKeyRange;
};

/**
 * Describes the message Ydb.Topic.DescribeTopicResult.PartitionInfo.
 * Use `create(DescribeTopicResult_PartitionInfoSchema)` to create a new message.
 */
export const DescribeTopicResult_PartitionInfoSchema: GenMessage<DescribeTopicResult_PartitionInfo> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 32, 0);

/**
 * @generated from message Ydb.Topic.DescribeTopicResult.TopicStats
 */
export type DescribeTopicResult_TopicStats = Message<"Ydb.Topic.DescribeTopicResult.TopicStats"> & {
  /**
   * Approximate size of topic.
   *
   * @generated from field: int64 store_size_bytes = 1;
   */
  storeSizeBytes: bigint;

  /**
   * Minimum of timestamps of last write among all partitions.
   *
   * @generated from field: google.protobuf.Timestamp min_last_write_time = 2;
   */
  minLastWriteTime?: Timestamp;

  /**
   * Maximum of differences between write timestamp and create timestamp for all messages, written during last minute.
   *
   * @generated from field: google.protobuf.Duration max_write_time_lag = 3;
   */
  maxWriteTimeLag?: Duration;

  /**
   * How much bytes were written statistics.
   *
   * @generated from field: Ydb.Topic.MultipleWindowsStat bytes_written = 4;
   */
  bytesWritten?: MultipleWindowsStat;
};

/**
 * Describes the message Ydb.Topic.DescribeTopicResult.TopicStats.
 * Use `create(DescribeTopicResult_TopicStatsSchema)` to create a new message.
 */
export const DescribeTopicResult_TopicStatsSchema: GenMessage<DescribeTopicResult_TopicStats> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 32, 1);

/**
 * Describe partition request sent from client to server.
 *
 * @generated from message Ydb.Topic.DescribePartitionRequest
 */
export type DescribePartitionRequest = Message<"Ydb.Topic.DescribePartitionRequest"> & {
  /**
   * @generated from field: Ydb.Operations.OperationParams operation_params = 1;
   */
  operationParams?: OperationParams;

  /**
   * Topic path.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Partition identifier.
   *
   * @generated from field: int64 partition_id = 3;
   */
  partitionId: bigint;

  /**
   * Include partition statistics.
   *
   * @generated from field: bool include_stats = 4;
   */
  includeStats: boolean;

  /**
   * Include partition location.
   *
   * @generated from field: bool include_location = 5;
   */
  includeLocation: boolean;
};

/**
 * Describes the message Ydb.Topic.DescribePartitionRequest.
 * Use `create(DescribePartitionRequestSchema)` to create a new message.
 */
export const DescribePartitionRequestSchema: GenMessage<DescribePartitionRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 33);

/**
 * Describe partition response sent from server to client.
 * If topic is not existed then response status will be "SCHEME_ERROR".
 *
 * @generated from message Ydb.Topic.DescribePartitionResponse
 */
export type DescribePartitionResponse = Message<"Ydb.Topic.DescribePartitionResponse"> & {
  /**
   * Result of request will be inside operation.
   *
   * @generated from field: Ydb.Operations.Operation operation = 1;
   */
  operation?: Operation;
};

/**
 * Describes the message Ydb.Topic.DescribePartitionResponse.
 * Use `create(DescribePartitionResponseSchema)` to create a new message.
 */
export const DescribePartitionResponseSchema: GenMessage<DescribePartitionResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 34);

/**
 * Describe partition result message that will be inside DescribePartitionResponse.operation.
 *
 * @generated from message Ydb.Topic.DescribePartitionResult
 */
export type DescribePartitionResult = Message<"Ydb.Topic.DescribePartitionResult"> & {
  /**
   * Partitions description.
   *
   * @generated from field: Ydb.Topic.DescribeTopicResult.PartitionInfo partition = 1;
   */
  partition?: DescribeTopicResult_PartitionInfo;
};

/**
 * Describes the message Ydb.Topic.DescribePartitionResult.
 * Use `create(DescribePartitionResultSchema)` to create a new message.
 */
export const DescribePartitionResultSchema: GenMessage<DescribePartitionResult> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 35);

/**
 * Describe topic's consumer request sent from client to server.
 *
 * @generated from message Ydb.Topic.DescribeConsumerRequest
 */
export type DescribeConsumerRequest = Message<"Ydb.Topic.DescribeConsumerRequest"> & {
  /**
   * @generated from field: Ydb.Operations.OperationParams operation_params = 1;
   */
  operationParams?: OperationParams;

  /**
   * Topic path.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Consumer name;
   *
   * @generated from field: string consumer = 3;
   */
  consumer: string;

  /**
   * Include consumer statistics.
   *
   * @generated from field: bool include_stats = 4;
   */
  includeStats: boolean;

  /**
   * Include partition location.
   *
   * @generated from field: bool include_location = 5;
   */
  includeLocation: boolean;
};

/**
 * Describes the message Ydb.Topic.DescribeConsumerRequest.
 * Use `create(DescribeConsumerRequestSchema)` to create a new message.
 */
export const DescribeConsumerRequestSchema: GenMessage<DescribeConsumerRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 36);

/**
 * Describe topic's consumer response sent from server to client.
 * If topic is not existed then response status will be "SCHEME_ERROR".
 *
 * @generated from message Ydb.Topic.DescribeConsumerResponse
 */
export type DescribeConsumerResponse = Message<"Ydb.Topic.DescribeConsumerResponse"> & {
  /**
   * Result of request will be inside operation.
   *
   * @generated from field: Ydb.Operations.Operation operation = 1;
   */
  operation?: Operation;
};

/**
 * Describes the message Ydb.Topic.DescribeConsumerResponse.
 * Use `create(DescribeConsumerResponseSchema)` to create a new message.
 */
export const DescribeConsumerResponseSchema: GenMessage<DescribeConsumerResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 37);

/**
 * Describe topic's consumer result message that will be inside DescribeConsumerResponse.operation.
 *
 * @generated from message Ydb.Topic.DescribeConsumerResult
 */
export type DescribeConsumerResult = Message<"Ydb.Topic.DescribeConsumerResult"> & {
  /**
   * Description of scheme object.
   *
   * @generated from field: Ydb.Scheme.Entry self = 1;
   */
  self?: Entry;

  /**
   * @generated from field: Ydb.Topic.Consumer consumer = 2;
   */
  consumer?: Consumer;

  /**
   * @generated from field: repeated Ydb.Topic.DescribeConsumerResult.PartitionInfo partitions = 3;
   */
  partitions: DescribeConsumerResult_PartitionInfo[];
};

/**
 * Describes the message Ydb.Topic.DescribeConsumerResult.
 * Use `create(DescribeConsumerResultSchema)` to create a new message.
 */
export const DescribeConsumerResultSchema: GenMessage<DescribeConsumerResult> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 38);

/**
 * @generated from message Ydb.Topic.DescribeConsumerResult.PartitionInfo
 */
export type DescribeConsumerResult_PartitionInfo = Message<"Ydb.Topic.DescribeConsumerResult.PartitionInfo"> & {
  /**
   * Partition identifier.
   *
   * @generated from field: int64 partition_id = 1;
   */
  partitionId: bigint;

  /**
   * Is partition open for write.
   *
   * @generated from field: bool active = 2;
   */
  active: boolean;

  /**
   * Ids of partitions which was formed when this partition was split or merged.
   *
   * @generated from field: repeated int64 child_partition_ids = 3;
   */
  childPartitionIds: bigint[];

  /**
   * Ids of partitions from which this partition was formed by split or merge.
   *
   * @generated from field: repeated int64 parent_partition_ids = 4;
   */
  parentPartitionIds: bigint[];

  /**
   * Stats for partition, filled only when include_stats in request is true.
   *
   * @generated from field: Ydb.Topic.PartitionStats partition_stats = 5;
   */
  partitionStats?: PartitionStats;

  /**
   * Stats for consumer of this partition, filled only when include_stats in request is true.
   *
   * @generated from field: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats partition_consumer_stats = 6;
   */
  partitionConsumerStats?: DescribeConsumerResult_PartitionConsumerStats;

  /**
   * Partition location, filled only when include_location in request is true.
   *
   * @generated from field: Ydb.Topic.PartitionLocation partition_location = 7;
   */
  partitionLocation?: PartitionLocation;
};

/**
 * Describes the message Ydb.Topic.DescribeConsumerResult.PartitionInfo.
 * Use `create(DescribeConsumerResult_PartitionInfoSchema)` to create a new message.
 */
export const DescribeConsumerResult_PartitionInfoSchema: GenMessage<DescribeConsumerResult_PartitionInfo> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 38, 0);

/**
 * @generated from message Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats
 */
export type DescribeConsumerResult_PartitionConsumerStats = Message<"Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats"> & {
  /**
   * Last read offset from this partition.
   *
   * @generated from field: int64 last_read_offset = 1;
   */
  lastReadOffset: bigint;

  /**
   * Committed offset for this partition.
   *
   * @generated from field: int64 committed_offset = 2;
   */
  committedOffset: bigint;

  /**
   * Reading this partition read session identifier.
   *
   * @generated from field: string read_session_id = 3;
   */
  readSessionId: string;

  /**
   * Timestamp of providing this partition to this session by server.
   *
   * @generated from field: google.protobuf.Timestamp partition_read_session_create_time = 4;
   */
  partitionReadSessionCreateTime?: Timestamp;

  /**
   * Timestamp of last read from this partition.
   *
   * @generated from field: google.protobuf.Timestamp last_read_time = 5;
   */
  lastReadTime?: Timestamp;

  /**
   * Maximum of differences between timestamp of read and write timestamp for all messages, read during last minute.
   *
   * @generated from field: google.protobuf.Duration max_read_time_lag = 6;
   */
  maxReadTimeLag?: Duration;

  /**
   * Maximum of differences between write timestamp and create timestamp for all messages, read during last minute.
   *
   * @generated from field: google.protobuf.Duration max_write_time_lag = 7;
   */
  maxWriteTimeLag?: Duration;

  /**
   * How much bytes were read during several windows statistics from this partition.
   *
   * @generated from field: Ydb.Topic.MultipleWindowsStat bytes_read = 8;
   */
  bytesRead?: MultipleWindowsStat;

  /**
   * Read session name, provided by client.
   *
   * @generated from field: string reader_name = 11;
   */
  readerName: string;

  /**
   * Host where read session connected.
   *
   * @generated from field: int32 connection_node_id = 12;
   */
  connectionNodeId: number;
};

/**
 * Describes the message Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.
 * Use `create(DescribeConsumerResult_PartitionConsumerStatsSchema)` to create a new message.
 */
export const DescribeConsumerResult_PartitionConsumerStatsSchema: GenMessage<DescribeConsumerResult_PartitionConsumerStats> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 38, 1);

/**
 * @generated from message Ydb.Topic.PartitionStats
 */
export type PartitionStats = Message<"Ydb.Topic.PartitionStats"> & {
  /**
   * Partition contains messages with offsets in range [start, end).
   *
   * @generated from field: Ydb.Topic.OffsetsRange partition_offsets = 1;
   */
  partitionOffsets?: OffsetsRange;

  /**
   * Approximate size of partition.
   *
   * @generated from field: int64 store_size_bytes = 2;
   */
  storeSizeBytes: bigint;

  /**
   * Timestamp of last write.
   *
   * @generated from field: google.protobuf.Timestamp last_write_time = 3;
   */
  lastWriteTime?: Timestamp;

  /**
   * Maximum of differences between write timestamp and create timestamp for all messages, written during last minute.
   *
   * @generated from field: google.protobuf.Duration max_write_time_lag = 4;
   */
  maxWriteTimeLag?: Duration;

  /**
   * How much bytes were written during several windows in this partition.
   *
   * @generated from field: Ydb.Topic.MultipleWindowsStat bytes_written = 5;
   */
  bytesWritten?: MultipleWindowsStat;

  /**
   * Partition host. Useful for debugging purposes.
   *
   * Use PartitionLocation
   *
   * @generated from field: int32 partition_node_id = 8 [deprecated = true];
   * @deprecated
   */
  partitionNodeId: number;
};

/**
 * Describes the message Ydb.Topic.PartitionStats.
 * Use `create(PartitionStatsSchema)` to create a new message.
 */
export const PartitionStatsSchema: GenMessage<PartitionStats> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 39);

/**
 * Update existing topic request sent from client to server.
 *
 * @generated from message Ydb.Topic.AlterTopicRequest
 */
export type AlterTopicRequest = Message<"Ydb.Topic.AlterTopicRequest"> & {
  /**
   * @generated from field: Ydb.Operations.OperationParams operation_params = 1;
   */
  operationParams?: OperationParams;

  /**
   * Topic path.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * partitioning_settings
   *
   * @generated from field: Ydb.Topic.AlterPartitioningSettings alter_partitioning_settings = 3;
   */
  alterPartitioningSettings?: AlterPartitioningSettings;

  /**
   * Retention settings.
   * Currently, only one limit may be set, so other should not be set.
   *
   * How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
   * Default limit - 36 hours.
   *
   * @generated from field: google.protobuf.Duration set_retention_period = 4;
   */
  setRetentionPeriod?: Duration;

  /**
   * How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
   *
   * @generated from field: optional int64 set_retention_storage_mb = 5;
   */
  setRetentionStorageMb?: bigint;

  /**
   * List of allowed codecs for writers.
   * Writes with codec not from this list are forbidden.
   * If empty, codec compatibility check for the topic is disabled.
   *
   * @generated from field: Ydb.Topic.SupportedCodecs set_supported_codecs = 7;
   */
  setSupportedCodecs?: SupportedCodecs;

  /**
   * Partition write speed in bytes per second. Must be less than database limit. Default limit - 1 MB/s.
   *
   * @generated from field: optional int64 set_partition_write_speed_bytes_per_second = 8;
   */
  setPartitionWriteSpeedBytesPerSecond?: bigint;

  /**
   * Burst size for write in partition, in bytes. Must be less than database limit. Default limit - 1 MB.
   *
   * @generated from field: optional int64 set_partition_write_burst_bytes = 9;
   */
  setPartitionWriteBurstBytes?: bigint;

  /**
   * User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
   * Leave the value blank to drop an attribute.
   *
   * @generated from field: map<string, string> alter_attributes = 10;
   */
  alterAttributes: { [key: string]: string };

  /**
   * Add consumers.
   *
   * @generated from field: repeated Ydb.Topic.Consumer add_consumers = 11;
   */
  addConsumers: Consumer[];

  /**
   * Remove consumers (by their names)
   *
   * @generated from field: repeated string drop_consumers = 12;
   */
  dropConsumers: string[];

  /**
   * Alter consumers
   *
   * @generated from field: repeated Ydb.Topic.AlterConsumer alter_consumers = 13;
   */
  alterConsumers: AlterConsumer[];

  /**
   * Set metering mode for topic in serverless database.
   *
   * @generated from field: Ydb.Topic.MeteringMode set_metering_mode = 14;
   */
  setMeteringMode: MeteringMode;
};

/**
 * Describes the message Ydb.Topic.AlterTopicRequest.
 * Use `create(AlterTopicRequestSchema)` to create a new message.
 */
export const AlterTopicRequestSchema: GenMessage<AlterTopicRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 40);

/**
 * Update topic response sent from server to client.
 *
 * @generated from message Ydb.Topic.AlterTopicResponse
 */
export type AlterTopicResponse = Message<"Ydb.Topic.AlterTopicResponse"> & {
  /**
   * Result of request will be inside operation.
   *
   * @generated from field: Ydb.Operations.Operation operation = 1;
   */
  operation?: Operation;
};

/**
 * Describes the message Ydb.Topic.AlterTopicResponse.
 * Use `create(AlterTopicResponseSchema)` to create a new message.
 */
export const AlterTopicResponseSchema: GenMessage<AlterTopicResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 41);

/**
 * Update topic result message that will be inside UpdateTopicResponse.operation.
 *
 * @generated from message Ydb.Topic.AlterTopicResult
 */
export type AlterTopicResult = Message<"Ydb.Topic.AlterTopicResult"> & {
};

/**
 * Describes the message Ydb.Topic.AlterTopicResult.
 * Use `create(AlterTopicResultSchema)` to create a new message.
 */
export const AlterTopicResultSchema: GenMessage<AlterTopicResult> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 42);

/**
 * Drop topic request sent from client to server.
 *
 * @generated from message Ydb.Topic.DropTopicRequest
 */
export type DropTopicRequest = Message<"Ydb.Topic.DropTopicRequest"> & {
  /**
   * @generated from field: Ydb.Operations.OperationParams operation_params = 1;
   */
  operationParams?: OperationParams;

  /**
   * Topic path.
   *
   * @generated from field: string path = 2;
   */
  path: string;
};

/**
 * Describes the message Ydb.Topic.DropTopicRequest.
 * Use `create(DropTopicRequestSchema)` to create a new message.
 */
export const DropTopicRequestSchema: GenMessage<DropTopicRequest> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 43);

/**
 * Drop topic response sent from server to client.
 * If topic not exists then response status will be "SCHEME_ERROR".
 *
 * @generated from message Ydb.Topic.DropTopicResponse
 */
export type DropTopicResponse = Message<"Ydb.Topic.DropTopicResponse"> & {
  /**
   * Result of request will be inside operation.
   *
   * @generated from field: Ydb.Operations.Operation operation = 1;
   */
  operation?: Operation;
};

/**
 * Describes the message Ydb.Topic.DropTopicResponse.
 * Use `create(DropTopicResponseSchema)` to create a new message.
 */
export const DropTopicResponseSchema: GenMessage<DropTopicResponse> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 44);

/**
 * Drop topic result message that will be inside DropTopicResponse.operation.
 *
 * @generated from message Ydb.Topic.DropTopicResult
 */
export type DropTopicResult = Message<"Ydb.Topic.DropTopicResult"> & {
};

/**
 * Describes the message Ydb.Topic.DropTopicResult.
 * Use `create(DropTopicResultSchema)` to create a new message.
 */
export const DropTopicResultSchema: GenMessage<DropTopicResult> = /*@__PURE__*/
  messageDesc(file_protos_ydb_topic, 45);

/**
 * @generated from enum Ydb.Topic.Codec
 */
export enum Codec {
  /**
   * @generated from enum value: CODEC_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CODEC_RAW = 1;
   */
  RAW = 1,

  /**
   * @generated from enum value: CODEC_GZIP = 2;
   */
  GZIP = 2,

  /**
   * @generated from enum value: CODEC_LZOP = 3;
   */
  LZOP = 3,

  /**
   * @generated from enum value: CODEC_ZSTD = 4;
   */
  ZSTD = 4,

  /**
   * User-defined codecs from 10000 to 19999
   *
   * @generated from enum value: CODEC_CUSTOM = 10000;
   */
  CUSTOM = 10000,
}

/**
 * Describes the enum Ydb.Topic.Codec.
 */
export const CodecSchema: GenEnum<Codec> = /*@__PURE__*/
  enumDesc(file_protos_ydb_topic, 0);

/**
 * @generated from enum Ydb.Topic.AutoPartitioningStrategy
 */
export enum AutoPartitioningStrategy {
  /**
   * The auto partitioning algorithm is not specified. The default value will be used.
   *
   * @generated from enum value: AUTO_PARTITIONING_STRATEGY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The auto partitioning is disabled.
   *
   * @generated from enum value: AUTO_PARTITIONING_STRATEGY_DISABLED = 1;
   */
  DISABLED = 1,

  /**
   * The auto partitioning algorithm will increase partitions count depending on the load characteristics.
   * The auto partitioning algorithm will never decrease the number of partitions.
   *
   * @generated from enum value: AUTO_PARTITIONING_STRATEGY_SCALE_UP = 2;
   */
  SCALE_UP = 2,

  /**
   * The auto partitioning algorithm will both increase and decrease partitions count depending on the load characteristics.
   *
   * @generated from enum value: AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN = 3;
   */
  SCALE_UP_AND_DOWN = 3,

  /**
   * The auto partitioning is paused.
   *
   * @generated from enum value: AUTO_PARTITIONING_STRATEGY_PAUSED = 4;
   */
  PAUSED = 4,
}

/**
 * Describes the enum Ydb.Topic.AutoPartitioningStrategy.
 */
export const AutoPartitioningStrategySchema: GenEnum<AutoPartitioningStrategy> = /*@__PURE__*/
  enumDesc(file_protos_ydb_topic, 1);

/**
 * Metering mode specifies the method used to determine consumption of resources by the topic.
 * This settings will have an effect only in a serverless database.
 *
 * @generated from enum Ydb.Topic.MeteringMode
 */
export enum MeteringMode {
  /**
   * Use default
   *
   * @generated from enum value: METERING_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Metering based on resource reservation
   *
   * @generated from enum value: METERING_MODE_RESERVED_CAPACITY = 1;
   */
  RESERVED_CAPACITY = 1,

  /**
   * Metering based on actual consumption. Default.
   *
   * @generated from enum value: METERING_MODE_REQUEST_UNITS = 2;
   */
  REQUEST_UNITS = 2,
}

/**
 * Describes the enum Ydb.Topic.MeteringMode.
 */
export const MeteringModeSchema: GenEnum<MeteringMode> = /*@__PURE__*/
  enumDesc(file_protos_ydb_topic, 2);

