// @generated by protoc-gen-es v2.2.3 with parameter "target=ts,import_extension=js"
// @generated from file ydb_query_v1.proto (package Ydb.Query.V1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { OperationSchema } from "./protos/ydb_operation_pb.js";
import { file_protos_ydb_operation } from "./protos/ydb_operation_pb.js";
import type { AttachSessionRequestSchema, BeginTransactionRequestSchema, BeginTransactionResponseSchema, CommitTransactionRequestSchema, CommitTransactionResponseSchema, CreateSessionRequestSchema, CreateSessionResponseSchema, DeleteSessionRequestSchema, DeleteSessionResponseSchema, ExecuteQueryRequestSchema, ExecuteQueryResponsePartSchema, ExecuteScriptRequestSchema, FetchScriptResultsRequestSchema, FetchScriptResultsResponseSchema, RollbackTransactionRequestSchema, RollbackTransactionResponseSchema, SessionStateSchema } from "./protos/ydb_query_pb.js";
import { file_protos_ydb_query } from "./protos/ydb_query_pb.js";

/**
 * Describes the file ydb_query_v1.proto.
 */
export const file_ydb_query_v1: GenFile = /*@__PURE__*/
  fileDesc("ChJ5ZGJfcXVlcnlfdjEucHJvdG8SDFlkYi5RdWVyeS5WMTKtBgoMUXVlcnlTZXJ2aWNlElIKDUNyZWF0ZVNlc3Npb24SHy5ZZGIuUXVlcnkuQ3JlYXRlU2Vzc2lvblJlcXVlc3QaIC5ZZGIuUXVlcnkuQ3JlYXRlU2Vzc2lvblJlc3BvbnNlElIKDURlbGV0ZVNlc3Npb24SHy5ZZGIuUXVlcnkuRGVsZXRlU2Vzc2lvblJlcXVlc3QaIC5ZZGIuUXVlcnkuRGVsZXRlU2Vzc2lvblJlc3BvbnNlEksKDUF0dGFjaFNlc3Npb24SHy5ZZGIuUXVlcnkuQXR0YWNoU2Vzc2lvblJlcXVlc3QaFy5ZZGIuUXVlcnkuU2Vzc2lvblN0YXRlMAESWwoQQmVnaW5UcmFuc2FjdGlvbhIiLllkYi5RdWVyeS5CZWdpblRyYW5zYWN0aW9uUmVxdWVzdBojLllkYi5RdWVyeS5CZWdpblRyYW5zYWN0aW9uUmVzcG9uc2USXgoRQ29tbWl0VHJhbnNhY3Rpb24SIy5ZZGIuUXVlcnkuQ29tbWl0VHJhbnNhY3Rpb25SZXF1ZXN0GiQuWWRiLlF1ZXJ5LkNvbW1pdFRyYW5zYWN0aW9uUmVzcG9uc2USZAoTUm9sbGJhY2tUcmFuc2FjdGlvbhIlLllkYi5RdWVyeS5Sb2xsYmFja1RyYW5zYWN0aW9uUmVxdWVzdBomLllkYi5RdWVyeS5Sb2xsYmFja1RyYW5zYWN0aW9uUmVzcG9uc2USVQoMRXhlY3V0ZVF1ZXJ5Eh4uWWRiLlF1ZXJ5LkV4ZWN1dGVRdWVyeVJlcXVlc3QaIy5ZZGIuUXVlcnkuRXhlY3V0ZVF1ZXJ5UmVzcG9uc2VQYXJ0MAESSwoNRXhlY3V0ZVNjcmlwdBIfLllkYi5RdWVyeS5FeGVjdXRlU2NyaXB0UmVxdWVzdBoZLllkYi5PcGVyYXRpb25zLk9wZXJhdGlvbhJhChJGZXRjaFNjcmlwdFJlc3VsdHMSJC5ZZGIuUXVlcnkuRmV0Y2hTY3JpcHRSZXN1bHRzUmVxdWVzdBolLllkYi5RdWVyeS5GZXRjaFNjcmlwdFJlc3VsdHNSZXNwb25zZUJPChd0ZWNoLnlkYi5wcm90by5xdWVyeS52MVo0Z2l0aHViLmNvbS95ZGItcGxhdGZvcm0veWRiLWdvLWdlbnByb3RvL1lkYl9RdWVyeV9WMWIGcHJvdG8z", [file_protos_ydb_operation, file_protos_ydb_query]);

/**
 * @generated from service Ydb.Query.V1.QueryService
 */
export const QueryService: GenService<{
  /**
   * Sessions are basic primitives for communicating with YDB Query Service. The are similar to
   * connections for classic relational DBs. Sessions serve three main purposes:
   * 1. Provide a flow control for DB requests with limited number of active channels.
   * 2. Distribute load evenly across multiple DB nodes.
   * 3. Store state for volatile stateful operations, such as short-living transactions.
   *
   * @generated from rpc Ydb.Query.V1.QueryService.CreateSession
   */
  createSession: {
    methodKind: "unary";
    input: typeof CreateSessionRequestSchema;
    output: typeof CreateSessionResponseSchema;
  },
  /**
   * @generated from rpc Ydb.Query.V1.QueryService.DeleteSession
   */
  deleteSession: {
    methodKind: "unary";
    input: typeof DeleteSessionRequestSchema;
    output: typeof DeleteSessionResponseSchema;
  },
  /**
   * @generated from rpc Ydb.Query.V1.QueryService.AttachSession
   */
  attachSession: {
    methodKind: "server_streaming";
    input: typeof AttachSessionRequestSchema;
    output: typeof SessionStateSchema;
  },
  /**
   * Short-living transactions allow transactional execution of several queries, including support
   * for interactive transactions. Transaction control can be implemented via flags in ExecuteQuery
   * call (recommended), or via explicit calls to Begin/Commit/RollbackTransaction.
   *
   * @generated from rpc Ydb.Query.V1.QueryService.BeginTransaction
   */
  beginTransaction: {
    methodKind: "unary";
    input: typeof BeginTransactionRequestSchema;
    output: typeof BeginTransactionResponseSchema;
  },
  /**
   * @generated from rpc Ydb.Query.V1.QueryService.CommitTransaction
   */
  commitTransaction: {
    methodKind: "unary";
    input: typeof CommitTransactionRequestSchema;
    output: typeof CommitTransactionResponseSchema;
  },
  /**
   * @generated from rpc Ydb.Query.V1.QueryService.RollbackTransaction
   */
  rollbackTransaction: {
    methodKind: "unary";
    input: typeof RollbackTransactionRequestSchema;
    output: typeof RollbackTransactionResponseSchema;
  },
  /**
   * Execute interactive query in a specified short-living transaction.
   * YDB query can contain DML, DDL and DCL statements. Supported mix of different statement types depends
   * on the chosen transaction type.
   * In case of error, including transport errors such as interrupted stream, whole transaction
   * needs to be retried. For non-idempotent transaction, a custom client logic is required to
   * retry conditionally retriable statuses, when transaction execution state is unknown.
   *
   * @generated from rpc Ydb.Query.V1.QueryService.ExecuteQuery
   */
  executeQuery: {
    methodKind: "server_streaming";
    input: typeof ExecuteQueryRequestSchema;
    output: typeof ExecuteQueryResponsePartSchema;
  },
  /**
   * Execute long-running script.
   * YDB scripts can contain all type of statements, including TCL statements. This way you can execute multiple
   * transactions in a single YDB script.
   * ExecuteScript call returns long-running Ydb.Operation object with:
   *   operation.metadata = ExecuteScriptMetadata
   *   operation.result = Empty
   * Script execution metadata contains all information about current execution state, including
   * execution_id, execution statistics and result sets info.
   * You can use standard operation methods such as Get/Cancel/Forget/ListOperations to work with script executions.
   * Script can be executed as persistent, in which case all execution information and results will be stored
   * persistently and available after successful or unsuccessful execution.
   *
   * @generated from rpc Ydb.Query.V1.QueryService.ExecuteScript
   */
  executeScript: {
    methodKind: "unary";
    input: typeof ExecuteScriptRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Fetch results for script execution using fetch_token for continuation.
   * For script with multiple result sets, parts of different results sets are interleaved in responses.
   * For persistent scripts, you can fetch results in specific position of specific result set using
   * position instead of fetch_token.
   *
   * @generated from rpc Ydb.Query.V1.QueryService.FetchScriptResults
   */
  fetchScriptResults: {
    methodKind: "unary";
    input: typeof FetchScriptResultsRequestSchema;
    output: typeof FetchScriptResultsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_ydb_query_v1, 0);

